{"meta":{"title":"Xian's Blog","subtitle":"见贤思齐焉，见不贤而内自省也。","description":"见贤思齐焉，见不贤而内自省也。","author":"Xian","url":"https://byxian.github.io"},"pages":[],"posts":[{"title":"Java面试通关要点汇总集微服务篇","slug":"Java面试通关要点汇总集之微服务篇","date":"2018-05-23T16:00:00.000Z","updated":"2018-05-23T18:01:07.089Z","comments":true,"path":"2018/05/24/Java面试通关要点汇总集之微服务篇/","link":"","permalink":"https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之微服务篇/","excerpt":"","text":"参考文档：http://www.spring4all.com/article/962 微服务篇微服务前后端分离是如何做的在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可。前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的组装和渲染，最终返回给浏览器。参考自： https://www.jianshu.com/p/fc0c63404cc7 和 http://2014.jsconf.cn/slides/herman-taobaoweb/index.html#/69 微服务哪些框架Dubbo，是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。阿里巴巴近几年对开源社区的贡献不论在国内还是国外都是引人注目的，比如：JStorm捐赠给Apache并加入Apache基金会等，为中国互联网人争足了面子，使得阿里巴巴在国人眼里已经从电商升级为一家科技公司了。Spring Cloud，从命名我们就可以知道，它是Spring Source的产物，Spring社区的强大背书可以说是Java企业界最有影响力的组织了，除了Spring Source之外，还有Pivotal和Netfix是其强大的后盾与技术输出。其中Netflix开源的整套微服务架构套件是Spring Cloud的核心。参考自：http://blog.didispace.com/microservice-framework/ 你怎么理解 RPC 框架请参考： https://www.zhihu.com/question/25536695 说说 RPC 的实现原理首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。参考自： https://liuzhengyang.github.io/2016/12/16/rpc-principle/ 说说 Dubbo 的实现原理dubbo作为rpc框架，实现的效果就是调用远程的方法就像在本地调用一样。如何做到呢？就是本地有对远程方法的描述，包括方法名、参数、返回值，在dubbo中是远程和本地使用同样的接口；然后呢，要有对网络通信的封装，要对调用方来说通信细节是完全不可见的，网络通信要做的就是将调用方法的属性通过一定的协议（简单来说就是消息格式）传递到服务端；服务端按照协议解析出调用的信息；执行相应的方法；在将方法的返回值通过协议传递给客户端；客户端再解析；在调用方式上又可以分为同步调用和异步调用；简单来说基本就这个过程作者：北冥有鱼链接：https://www.zhihu.com/question/52133065/answer/129153953来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 你怎么理解 RESTfulhttp://www.cnblogs.com/artech/p/3506553.html 说说如何设计一个良好的 APIhttps://juejin.im/entry/59b8d34c6fb9a00a4455dd04 如何理解 RESTful API 的幂等性http://blog.720ui.com/2016/restful_idempotent/ 如何保证接口的幂等性http://www.spring4all.com/article/914 说说 CAP 定理、 BASE 理论http://my.oschina.net/foodon/blog/372703 怎么考虑数据一致性问题https://opentalk.upyun.com/310.html 说说最终一致性的实现方案http://www.cnblogs.com/soundcode/p/5590710.html 你怎么看待微服务http://dockone.io/article/394 微服务与 SOA 的区别http://dockone.io/article/2399 如何拆分服务http://dockone.io/article/2516 微服务如何进行数据库管理http://www.uml.org.cn/wfw/201705271.asp 如何应对微服务的链式调用异常http://blog.720ui.com/2017/msa_design/?utm_source=tuicool&amp;utm_medium=referral 对于快速追踪与定位问题依赖日志 微服务的安全http://dockone.io/article/1507 分布式谈谈业务中使用分布式的场景https://segmentfault.com/q/1010000006095431/a-1020000006114658 Session 分布式方案https://yq.aliyun.com/articles/387723 分布式锁的场景https://yq.aliyun.com/articles/465311 分布是锁的实现方案https://yq.aliyun.com/articles/60663 分布式事务http://www.hollischuang.com/archives/681 集群与负载均衡的算法与实现https://yq.aliyun.com/articles/218895 说说分库与分表设计http://blog.720ui.com/2017/mysql_core_08_multi_db_table/ 分库与分表带来的分布式困境与应对之策http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/ 安全问题安全要素与 STRIDE 威胁http://blog.720ui.com/2017/security_stride/ 防范常见的 Web 攻击http://blog.720ui.com/2016/security_web/ 服务端通信安全攻防http://blog.720ui.com/2016/security_data_transmission/ HTTPS 原理剖析http://blog.720ui.com/2016/security_https/ HTTPS 降级攻击http://blog.jobbole.com/106792/ 授权与认证https://www.jianshu.com/p/cda95dff698c 基于角色的访问控制https://www.douban.com/note/259930498/ 基于数据的访问控制https://www.zhihu.com/question/64888533 性能优化性能指标有哪些https://www.douban.com/note/168911628/ 如何发现性能瓶颈http://blog.csdn.net/shan9liang/article/details/24035001 性能调优的常见手段http://blog.csdn.net/jyonghu003/article/details/70055832 说说你在项目中如何进行性能调优https://www.jianshu.com/p/08d029607b9a","categories":[],"tags":[]},{"title":"Java面试通关要点汇总集工程篇","slug":"Java面试通关要点汇总集之工程篇","date":"2018-05-23T16:00:00.000Z","updated":"2018-05-23T18:10:40.694Z","comments":true,"path":"2018/05/24/Java面试通关要点汇总集之工程篇/","link":"","permalink":"https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之工程篇/","excerpt":"","text":"参考文档：http://www.spring4all.com/article/970 工程篇需求分析你如何对需求原型进行理解和拆分http://www.woshipm.com/pmd/712972.html 说说你对功能性需求的理解https://www.zhihu.com/question/24191618 说说你对非功能性需求的理解https://www.zhihu.com/question/24191618 你针对产品提出哪些交互和改进意见http://www.weiued.com/a/7b054284-a6ae-4b55-964b-27f209c86abb 你如何理解用户痛点http://www.woshipm.com/pmd/191214.html 设计能力说说你在项目中使用过的 UML 图http://www.uml.org.cn/oobject/200811191.asp 你如何考虑组件化https://yq.aliyun.com/articles/7239 你如何考虑服务化http://www.hollischuang.com/archives/1628 你如何进行领域建模http://www.cnblogs.com/yangjin-55/archive/2012/08/21/2786515.html 你如何划分领域边界http://www.cnblogs.com/daxnet/archive/2011/12/24/2300169.html 说说你项目中的领域建模http://www.cnblogs.com/wayfarer/p/5339134.html 说说概要设计https://baike.baidu.com/item/%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1 设计模式你项目中有使用哪些设计模式http://blog.sina.com.cn/s/blog_155bb57fe0102w9z7.html 说说常用开源框架中设计模式使用分析http://www.spring4all.com/article/507 说说你对设计原则的理解http://www.cnblogs.com/areliang/archive/2006/03/07/345111.html 23种设计模式的设计理念http://www.cnblogs.com/pony1223/p/7608955.html 设计模式之间的异同，例如策略模式与状态模式的区别http://www.blogjava.net/4cai/archive/2014/05/16/413717.html 设计模式之间的结合，例如策略模式+简单工厂模式的实践http://www.cnblogs.com/skychen1218/p/4770876.html 设计模式的性能，例如单例模式哪种性能更好。https://www.tuicool.com/articles/NVza2am 业务工程你系统中的前后端分离是如何做的说说你的开发流程你和团队是如何沟通的你如何进行代码评审说说你对技术与业务的理解说说你在项目中经常遇到的 Exception说说你在项目中遇到感觉最难Bug，怎么解决的说说你在项目中遇到印象最深困难，怎么解决的你觉得你们项目还有哪些不足的地方你是否遇到过 CPU 100% ，如何排查与解决https://yq.aliyun.com/wenji/194955 你是否遇到过 内存 OOM ，如何排查与解决http://www.cnblogs.com/ThinkVenus/p/6805495.html 说说你对敏捷开发的实践https://zhuanlan.zhihu.com/youdaonote/19571416 说说你对开发运维的实践https://wenku.baidu.com/view/99e53876b9f3f90f77c61b8d.html 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色 软实力说说你的亮点说说你最近在看什么书说说你觉得最有意义的技术书籍工作之余做什么事情说说个人发展方向方面的思考http://www.cnblogs.com/brucewangxin/archive/2013/02/08/2909342.html 说说你认为的服务端开发工程师应该具备哪些能力https://yq.aliyun.com/articles/88423 说说你认为的架构师是什么样的，架构师主要做什么https://www.zhihu.com/question/43515235 说说你所理解的技术专家https://www.zhihu.com/question/43515235","categories":[],"tags":[]},{"title":"Java面试通关要点汇总集核心篇","slug":"Java面试通关要点汇总集之核心篇","date":"2018-05-23T16:00:00.000Z","updated":"2018-05-23T16:54:22.174Z","comments":true,"path":"2018/05/24/Java面试通关要点汇总集之核心篇/","link":"","permalink":"https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/","excerpt":"","text":"参考文档：http://www.spring4all.com/article/929 核心篇数据存储MySQL 索引使用的注意事项 索引不会包含有NULL的列 1只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。 使用短索引 1对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 索引列排序 1mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。 like语句操作 1一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。 不要在列上进行运算 不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的 索引要建立在经常进行select操作的字段上 1这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 索引要建立在值比较唯一的字段上。 对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。 在where和join中出现的列需要建立索引。 where的查询条件里有不等号(where column != …),mysql将无法使用索引。 如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。 在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。说说反模式设计简单的来说，反模式是指在对经常面对的问题经常使用的低效，不良，或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。在这里我举一个最简单的例子：在面向对象设计/编程中，有一条很重要的原则， 单一责任原则(Single responsibility principle)。其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能。很多维护老程序的开发人员们可能都遇过这种类，一个类里有几千行的代码，有很多功能，但是责任不明确单一。单元测试程序也变复杂无比。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是开发人员故意的。很多情况下主要是由于随着系统的年限，需求的变化，项目的资源压力，项目组人员流动，系统结构的变化而导致某些原先小型的，符合单一原则类慢慢的变的臃肿起来。最后当这个类变成了维护的噩梦(特别是原先熟悉的开发人员离职后)，重构该类就变成了一个不容易的工程。说说分库与分表设计垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。以上摘抄自： http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table分库与分表带来的分布式困境与应对之策数据迁移与扩容问题前面介绍到水平分表策略归纳总结为随机分表和连续分表两种情况。连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。连续分表的另外一个好处在于比较容易，不需要考虑迁移旧的数据，只需要添加分表就可以自动扩容。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。针对于水平分表的设计至关重要，需要评估中短期内业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要多少分片。对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。表关联问题在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。分页与排序问题一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。分布式事务问题随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题。目前，分布式事务并没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。分布式全局唯一ID在单库单表的情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单。在分库分表的环境中，数据分布在不同的分表上，不能再借助数据库自增长特性。需要使用全局唯一 ID，例如 UUID、GUID等。关于如何选择合适的全局唯一 ID，我会在后面的章节中进行介绍。摘抄自：http://blog.csdn.net/jiangpingjiangping/article/details/78069480说说 SQL 优化之道一、一些常见的SQL实践（1）负向条件查询不能使用索引select from order where status!=0 and stauts!=1not in/not exists都不是好习惯可以优化为in查询：select from order where status in(2,3)（2）前导模糊查询不能使用索引select from order where desc like ‘%XX’而非前导模糊查询则可以：select from order where desc like ‘XX%’（3）数据区分度不大的字段不宜使用索引select from user where sex=1原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。（4）在属性上进行计算不能命中索引select from order where YEAR(date) &lt; = ‘2017’即使date上建立了索引，也会全表扫描，可优化为值计算：select from order where date &lt; = CURDATE()或者：select from order where date &lt; = ‘2017-01-01’二、并非周知的SQL实践（5）如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心select from user where uid=?select from user where login_name=?原因：B-Tree索引的时间复杂度是O(log(n))；Hash索引的时间复杂度是O(1)（6）允许为null的列，查询有潜在大坑单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集select from user where name != ‘shenjian’如果name允许为null，索引不存储null值，结果集中不会包含这些记录。所以，请使用not null约束以及默认值。（7）复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致用户中心建立了(login_name, passwd)的复合索引select from user where login_name=? and passwd=?select from user where passwd=? and login_name=?都能够命中索引select from user where login_name=?也能命中索引，满足复合索引最左前缀select from user where passwd=?不能命中索引，不满足复合索引最左前缀（8）使用ENUM而不是字符串ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。三、小众但有用的SQL实践（9）如果明确知道只有一条结果返回，limit 1能够提高效率select from user where login_name=?可以优化为：select from user where login_name=? limit 1原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动（10）把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果select from order where date &lt; = CURDATE()这不是一个好的SQL实践，应该优化为：$curDate = date(‘Y-m-d’);$res = mysqlquery(‘select from order where date &lt; = $curDate’);原因：释放了数据库的CPU多次调用，传入的SQL相同，才可以利用查询缓存（11）强制类型转换会全表扫描select from user where phone=13800001234你以为会命中phone索引么？大错特错了，这个语句究竟要怎么改？末了，再加一条，不要使用select *（潜台词，文章的SQL都不合格 ==），只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。整理自：https://cloud.tencent.com/developer/article/1054203MySQL 遇到的死锁问题产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。下列方法有助于最大限度地降低死锁：（1）按同一顺序访问对象。（2）避免事务中的用户交互。（3）保持事务简短并在一个批处理中。（4）使用低隔离级别。（5）使用绑定连接。整理自： http://onwise.xyz/2017/04/20/mysql-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/存储引擎的 InnoDB 与 MyISAM InnoDB不支持FULLTEXT类型的索引。 InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。 DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。 另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”数据库索引的原理数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。为什么要用 B-tree一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。聚集索引与非聚集索引的区别1).聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个2).聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续 3).聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序 非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.4).索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。limit 20000 加载很慢怎么解决mysql的性能低是因为数据库要去扫描N+M条记录，然后又要放弃之前N条记录，开销很大解决思略：1、前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用es等进行搜索2、使用延迟关联，即先通用limit得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据select a.* from a,(select id from table_1 where is_deleted=’N’ limit 100000,20) b where a.id = b.id3、从业务上实现，不分页如此多，例如只能分页前100页，后面的不允许再查了4、不使用limit N,M,而是使用limit N，即将offset转化为where条件。选择合适的分布式主键方案 数据库自增长序列或字段 UUID 使用UUID to Int64的方法 Redis生成ID Twitter的snowflake算法 利用zookeeper生成唯一ID MongoDB的ObjectId选择合适的数据存储方案关系型数据库 MySQLMySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。内存数据库 Redis随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。文档数据库 MongoDBMongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。列族数据库 HBaseHBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。全文搜索引擎 ElasticSearch在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。摘抄自：http://blog.720ui.com/2017/db_better_db_use/ObjectId 规则[0,1,2,3] [4,5,6] [7,8] [9,10,11]时间戳 |机器码 |PID |计数器前四位是时间戳，可以提供秒级别的唯一性。接下来三位是所在主机的唯一标识符，通常是机器主机名的散列值。接下来两位是产生ObjectId的PID，确保同一台机器上并发产生的ObjectId是唯一的。前九位保证了同一秒钟不同机器的不同进程产生的ObjectId时唯一的。最后三位是自增计数器，确保相同进程同一秒钟产生的ObjectId是唯一的。https://github.com/qianjiahao/MongoDB/wiki/MongoDB%E4%B9%8B_id%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99聊聊 MongoDB 使用场景高伸缩性的场景MongoDB 非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。日志系统的场景日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。分布式文件存储MongoDB 还适合存储大尺寸的数据，之前介绍的 GridFS 存储方案，就是基于 MongoDB 的分布式文件存储系统。摘抄自： http://blog.720ui.com/2017/mongodb_core_use/倒排索引倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。有两种不同的反向索引形式：一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。聊聊 ElasticSearch 使用场景全文搜索，这个是用的最多的。加上分词插件、拼音插件什么的可以做成强大的全文搜索引擎。数据库，挺奇葩的用法，因为ES存数相同数据，更费空间，不过确实不错，因为他的强大统计分析汇总能力，再加上分布式P2P扩展能力，现在硬件又那么便宜，所以就有人拿来当数据库了。在线统计分析引擎，日志系统。logstash，不用解释了吧。可以实时动态分析数据，很是爽。缓存使用Redis 有哪些类型123456在Redis中有五种数据类型String----------字符串Hash------------字典List-------------列表Set--------------集合Sorted Set------有序集合 Redis 内部结构Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。type ：代表一个 value 对象具体是何种数据类型。encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如：”123” “456”这样的字符串。vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。作者：zhanglbjames链接：https://www.jianshu.com/p/f09480c05e42來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 聊聊 Redis 使用场景123456789101112缓存会话缓存时效性访问频率计数器社交列表记录用户判定信息交集、并集和差集热门列表与排行榜最新动态消息队列摘抄自：http://blog.720ui.com/2017/redis_core_use/ Redis 持久化机制12redis有两种持久化机制RDB与AOF。摘抄自： http://shanks.leanote.com/post/Untitled-55ca439338f41148cd000759-22 Redis 如何实现持久化1234RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。 Redis 集群方案与实现123456789客户端分片基于代理的分片路由查询客户端分片由客户端决定key写入或者读取的节点。包括jedis在内的一些客户端，实现了客户端分片机制。路由查询将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。开源方案 Redis 为什么是单线程的1因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。 缓存奔溃12碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。 缓存降级页面降级：在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；页面片段降级：比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；服务功能降级：比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。爬虫降级：在大促活动时，可以将爬虫流量导向静态页或者返回空数据，从而保护后端稀缺资源。自动开关降级自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。超时降级当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。摘抄自： http://jinnianshilongnian.iteye.com/blog/2306477 使用缓存的合理性问题123456789热点数据，缓存才有价值频繁修改的数据，看情况考虑使用缓存数据不一致性缓存更新机制缓存可用性缓存服务降级缓存预热缓存穿透摘抄自： http://blog.720ui.com/2016/redis_action_01_use_core/ 消息队列消息队列的使用场景1234校验用户名等信息，如果没问题会在数据库中添加一个用户记录如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他发送给用户一个包含操作指南的系统通知 消息的重发补偿解决思路12345可靠消息服务定时查询状态为已发送并超时的消息可靠消息将消息重新投递到 MQ 组件中下游应用监听消息，在满足幂等性的条件下，重新执行业务。下游应用通知可靠消息服务该消息已经成功消费。通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。 消息的幂等性解决思路12345678910111213141516171819202122232425查询操作查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作删除操作删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)3.唯一索引，防止新增脏数据比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录token机制，防止页面重复提交悲观锁获取数据的时候加锁获取select * from table_xxx where id=&apos;xxx&apos; for update;注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用乐观锁乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。分布式锁还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。select + insert并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了注意：核心高并发流程不要用这种方法状态机幂等在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。对外提供接口的api如何保证幂等如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)摘抄自： http://825635381.iteye.com/blog/2276077 消息的堆积解决思路123456如果还没开始投入使用kafka，那应该在设计分区数的时候，尽量设置的多点（当然也不要太大，太大影响延迟，具体可以参考我前面提到的文章），从而提升生产和消费的并行度，避免消费太慢导致消费堆积。增大批次瓶颈在消费吞吐量的时候，增加批次也可以改善性能增加线程数如果一些消费者组中的消费者线程还是有1个消费者线程消费多个分区的情况，建议增加消费者线程。尽量1个消费者线程对应1个分区，从而发挥现有分区数下的最大并行度。摘抄自： https://kaimingwan.com/post/framworks/kafka/kafkaxiao-xi-dui-ji-chu-li 自己如何实现消息队列1234567大体上的设计是由一条线程1执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.添加一条线程1主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,当任务队列长度达到最大值时,线程1将被阻塞,等待线程2,3...从任务队列取出任务执行。作者：DrJasonZhang链接：https://www.jianshu.com/p/2d2271ecc64d來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 如何保证消息的有序性12通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。订单号相同的消息会被先后发送到同一个队列中，在获取到路由信息以后，会根据算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。","categories":[],"tags":[]},{"title":"Java面试通关要点汇总集框架篇","slug":"Java面试通关要点汇总集之框架篇","date":"2018-05-23T16:00:00.000Z","updated":"2018-05-23T18:00:06.027Z","comments":true,"path":"2018/05/24/Java面试通关要点汇总集之框架篇/","link":"","permalink":"https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之框架篇/","excerpt":"","text":"参考文档：http://www.spring4all.com/article/951 框架篇SpringBeanFactory 和 ApplicationContext 有什么区别BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。提供了支持国际化的文本消息统一的资源文件读取方式已在监听器中注册的bean的事件摘抄自： http://www.importnew.com/15851.html Spring Bean 的生命周期Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。初始化之后调用的回调方法。销毁之前调用的回调方法。Spring框架提供了以下四种方式来管理bean的生命周期事件：InitializingBean和DisposableBean回调接口针对特殊行为的其他Aware接口Bean配置文件中的Custom init()方法和destroy()方法@PostConstruct和@PreDestroy注解方式摘抄自： http://www.importnew.com/15851.html Spring IOC 如何实现Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。 说说 Spring AOP面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update方法的执行时间时间，操作人等等信息，记录到日志，通过spring的AOP技术，就可以在不修改update的代码的情况下完成该需求。 Spring AOP 实现原理Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。 动态代理（cglib 与 JDK）JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。而CGLIB则可以实现对类的动态代理。摘抄自： http://www.importnew.com/22015.html Spring 事务实现方式1、编码方式所谓编程式事务指的是通过编码方式实现事务，即类似于JDBC编程实现事务管理。2、声明式事务管理方式声明式事务管理又有两种实现方式：基于xml配置文件的方式；另一个实在业务方法上进行@Transaction注解，将事务规则应用到业务逻辑中 Spring 事务底层原理a、划分处理单元——IOC由于spring解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用spring中的IOC划分了事务处理单元。并且将对事务的各种配置放到了ioc容器中（设置事务管理器，设置事务的传播特性及隔离机制）。b、AOP拦截需要进行事务处理的类Spring事务处理模块是通过AOP功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用TransactionProxyFactoryBean接口来使用AOP功能，生成proxy代理对象，通过TransactionInterceptor完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取ioc容器事务配置属性，转化为spring事务处理需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为TransactionAttribute表示的数据对象。c、对事物处理实现（事务的生成、提交、回滚、挂起）spring委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource数据源支持、hibernate数据源事务处理支持、JDO数据源事务处理支持，JPA、JTA数据源事务处理支持。这些支持都是通过设计PlatformTransactionManager、AbstractPlatforTransaction一系列事务处理的支持。 为常用数据源支持提供了一系列的TransactionManager。d、结合PlatformTransactionManager实现了TransactionInterception接口，让其与TransactionProxyFactoryBean结合起来，形成一个Spring声明式事务处理的设计体系。 如何自定义注解实现功能创建自定义注解和创建一个接口相似，但是注解的interface关键字需要以@符号开头。注解方法不能带有参数；注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组；注解方法可以有默认值；注解本身能够包含元注解，元注解被用来注解其它注解。摘抄自：http://www.importnew.com/20286.html Spring MVC 运行流程1.spring mvc将所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.3.DispatcherServlet请请求提交到目标Controller4.Controller进行业务逻辑处理后，会返回一个ModelAndView5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象6.视图对象负责渲染返回给客户端。摘抄自：http://blog.csdn.net/liangzi_lucky/article/details/52459378 Spring MVC 启动流程在 web.xml 文件中给 Spring MVC 的 Servlet 配置了 load-on-startup,所以程序启动的时候会初始化 Spring MVC，在 HttpServletBean 中将配置的 contextConfigLocation属性设置到 Servlet 中，然后在 FrameworkServlet 中创建了 WebApplicationContext,DispatcherServlet 根据 contextConfigLocation 配置的 classpath 下的 xml 文件初始化了Spring MVC 总的组件。摘自： 《SpringMVC 源代码分析与实践》 Spring 的单例实现原理Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 ConcurrentHashMap 对象。摘抄自：http://blog.720ui.com/2017/design_pattern_singleton_reg/ Spring 框架中用到了哪些设计模式代理模式—在AOP和remoting中被用的比较多。单例模式—在spring配置文件中定义的bean默认为单例模式。模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。前端控制器—Spring提供了DispatcherServlet来对请求进行分发。视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。工厂模式—BeanFactory用来创建对象的实例。摘抄自： http://www.importnew.com/15851.html#design_patterns_used_in_spring Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等） Netty为什么选择 Netty1) API使用简单，开发门槛低；2) 功能强大，预置了多种编解码功能，支持多种主流协议；3) 定制能力强，可以通过 ChannelHandler 对通信框架进行灵活的扩展；4) 性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；5) 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；6) 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；7) 经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。正是因为这些优点，Netty逐渐成为Java NIO编程的首选框架。摘抄自：http://ifeve.com/netty-2-6/ 说说业务中，Netty 的使用场景构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供高性能、低时延的通信服务；公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的WebSocket协议栈；各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。摘抄自：http://www.voidcn.com/article/p-xydqhgxk-uk.html 原生的 NIO 在 JDK 1.7 版本存在 epoll bug它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK 1.6版本的update18修复了该问题，但是直到JDK 1.7版本该问题仍旧存在，只不过该BUG发生概率降低了一些而已，它并没有得到根本性解决。摘抄自： http://blog.csdn.net/broadview2006/article/details/46041995 什么是TCP 粘包/拆包1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。摘抄自：https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/ TCP粘包/拆包的解决办法1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。摘抄自：https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/ Netty 线程模型首先，Netty使用EventLoop来处理连接上的读写事件，而一个连接上的所有请求都保证在一个EventLoop中被处理，一个EventLoop中只有一个Thread，所以也就实现了一个连接上的所有事件只会在一个线程中被执行。一个EventLoopGroup包含多个EventLoop，可以把一个EventLoop当做是Reactor线程模型中的一个线程，而一个EventLoopGroup类似于一个ExecutorService作者：一字马胡链接：https://www.jianshu.com/p/128ddc36e713來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 说说 Netty 的零拷贝“零拷贝”是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。 Netty 内部执行流程Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。摘抄自：http://blog.onlycatch.com/post/Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D Netty 重连实现1.心跳机制检测连接存活2.启动时连接重试3.运行中连接断开时重试摘抄自：http://www.spring4all.com/article/889","categories":[],"tags":[]},{"title":"Java面试通关要点汇总集基础篇","slug":"Java面试通关要点汇总集基础篇","date":"2018-05-23T14:00:00.000Z","updated":"2018-05-23T16:05:57.669Z","comments":true,"path":"2018/05/23/Java面试通关要点汇总集基础篇/","link":"","permalink":"https://byxian.github.io/2018/05/23/Java面试通关要点汇总集基础篇/","excerpt":"","text":"参考文档：http://www.spring4all.com/article/917 基础篇基本功面向对象的特征123456789面向对象的三个基本特征是：封装、继承、多态。封装封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。继承面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。多态多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。实现多态，有二种方式，覆盖，重载。 final, finally, finalize 的区别123final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.finally 是异常处理语句结构的一部分，表示总是执行.finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用. int 和 Integer 有什么区别1234567int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，是引用类型，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，Java中int和Integer关系是比较微妙的。关系如下：1、int是基本的数据类型；2、Integer是int的封装类；3、int和Integer都可以表示某一个数值；4、int和Integer不能够互用，因为他们两种不同的数据类型； 重载和重写的区别12重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。 抽象类和接口有什么区别 参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实现 实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法 抽象方法可以有main方法并且我们可以运行它 接口没有main方法，因此我们不能运行它。 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 说说反射的用途及实现123456Java反射机制是一个非常强大的功能，在很多的项目比如Spring，Mybatis都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决java泛型擦除等令人苦恼的问题。获取一个对象对应的反射类，在Java中有三种方法可以获取一个对象的反射类，通过getClass()方法通过Class.forName()方法；使用类.class通过类加载器实现，getClassLoader() 说说自定义注解的场景及实现12345登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。反射的实现在 Java 应用层面上讲，是通过对 Class 对象的操作实现的，Class 对象为我们提供了一系列方法对类进行操作。在 Jvm 这个角度来说，Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目按严格的顺序紧凑的排列在 Class 文件中，里面包含了类、方法、字段等等相关数据。通过对 Claas 数据流的处理我们即可得到字段、方法等数据。作者：LeopPro链接：https://juejin.im/post/5a9fad016fb9a028b77a5ce9来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 HTTP 请求的 GET 与 POST 方式的区别12341.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。3.首先是&quot;GET方式提交的数据最多只能是1024字节&quot;，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。POST是没有大小限制的，HTTP协议规范也没有进行大小限制 session 与 cookie 区别1234567891、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议：将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中 session 分布式处理123456789101112131415161718192021222324252627281.Session复制在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。优点：代码上不需要做支持和修改。缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。适用场景：只适用于Web服务器比较少且Session数据量少的情况。可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。2.Session粘滞将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。优点：使用简单，没有额外开销。缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。适用场景：对稳定性要求不是很高的业务情景。3.Session集中管理在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。优点：可靠性高，减少Web服务器的资源开销。缺点：实现上有些复杂，配置较多。适用场景：Web服务器较多、要求高可用性的情况。可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。4.基于Cookie管理这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。优点：不需要依赖额外外部存储，不需要额外配置。缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。适用场景：数据不重要、不敏感且数据量小的情况。总结这四种方式，相对来说，Session集中管理更加可靠，使用也是最多的。作者：JavaQ链接：https://www.jianshu.com/p/3dd4e06bdfa4來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 JDBC 流程12345（1）向DriverManager类注册驱动数据库驱动程序（2）调用DriverManager.getConnection方法， 通过JDBC URL，用户名，密码取得数据库连接的Connection对象。（3）获取Connection后， 便可以通过createStatement创建Statement用以执行SQL语句。（4） 有时候会得到查询结果，比如select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。（5）关闭数据库语句，关闭数据库连接。 MVC 设计思想12345MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。1）最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。2）最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。3）中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。 equals 与 == 的区别1234567==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。==返回true如果两个引用指向相同的对象，equals()的返回结果依赖于具体业务实现字符串的对比使用equals()代替==操作符使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。==返回true如果两个引用指向相同的对象，equals()的返回结果依赖于具体业务实现字符串的对比使用equals()代替==操作符 集合List 和 Set 区别1231、List,Set都是继承自Collection接口2、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）3、List接口有三个实现类：LinkedList，ArrayList，Vector ，Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet Arraylist 与 LinkedList 区别1234561) 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。2) 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。3) 类似于插入数据，删除数据时，LinkedList也优于ArrayList。4) LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。5) 你的应用不会随机访问数据。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。6) 你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。 ArrayList 与 Vector 区别12345链接：https://www.nowcoder.com/questionTerminal/0953369f92054cbfbf1024a1e723e04f来源：牛客网1） 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数2。2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50% ，这样,ArrayList就有利于节约内存空间。如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。 HashMap 和 Hashtable 的区别123451)HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。2) HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。3) 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。4) 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。5) HashMap不能保证随着时间的推移Map中的元素次序是不变的。 HashSet 和 HashMap 区别 HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 HashMap 和 ConcurrentHashMap 的区别123451）放入HashMap的元素是key-value对。2）底层说白了就是以前数据结构课程讲过的散列结构。3）要将元素放入到hashmap中，那么key的类型必须要实现实现hashcode方法，默认这个方法是根据对象的地址来计算的，具体我也记不太清楚了，接着还必须覆盖对象的equal方法。4）ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有5）ConcurrentHashMap在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。。。 HashMap 的工作原理及代码实现1234HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。 ConcurrentHashMap 的工作原理及代码实现123ConcurrentHashMap采用了非常精妙的&quot;分段锁&quot;策略，ConcurrentHashMap的主干是个Segment数组。Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。 线程创建线程的方式及实现123456789101112131415161718192021221.继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。（2）创建Thread子类的实例，即创建了线程对象。（3）调用线程对象的start()方法来启动该线程。2.通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。3.通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值采用实现Runnable、Callable接口的方式创见多线程时，优势是：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。劣势是：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。使用继承Thread类的方式创建多线程时优势是：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。 sleep() 、join（）、yield（）有什么区别1234567891011sleep() sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。wait() wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。 wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。 除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。 此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。yield() yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。join() join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行 说说 CountDownLatch 原理12CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。 说说 CyclicBarrier 原理1CyclicBarrier简介CyclicBarrier是一个同步辅助类,允许一组线程互相等待,直到到达某个公共屏障点(commonbarrierpoint)。因为该barrier在释放等待线程后可以重用,所以称它为循环的barrier。 说说 Semaphore 原理1Semaphore直译为信号。实际上Semaphore可以看做是一个信号的集合。不同的线程能够从Semaphore中获取若干个信号量。当Semaphore对象持有的信号量不足时，尝试从Semaphore中获取信号的线程将会阻塞。直到其他线程将信号量释放以后，阻塞的线程会被唤醒，重新尝试获取信号量。 说说 Exchanger 原理1当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。 说说 CountDownLatch 与 CyclicBarrier 区别12(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行;而CyclicBarrier则是允许N个线程相互等待。(02) CountDownLatch的计数器无法被重置;CyclicBarrier的计数器可以被重置后使用,因此它被称为是循环的barrier。 ThreadLocal 原理分析1ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。 讲讲线程池的实现原理1234567当提交一个新任务到线程池时，线程池的处理流程如下。1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 线程池的几种方式123456在Executors类里面提供了一些静态工厂，生成一些常用的线程池。1、newFixedThreadPool：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。2、newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。3、newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。4、newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。5、newSingleThreadScheduledExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 线程的生命周期1新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态 锁机制说说线程安全问题1234567线程安全是多线程领域的问题，线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。在Java多线程编程当中，提供了多种实现Java线程安全的方式：最简单的方式，使用Synchronization关键字:Java Synchronization介绍使用java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger使用java.util.concurrent.locks 包中的锁使用线程安全的集合ConcurrentHashMap使用volatile关键字，保证变量可见性（直接从内存读，而不是从线程cache读） volatile 实现原理12在JVM底层volatile是采用“内存屏障”来实现的。缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。 synchronize 实现原理1同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。 synchronized 与 lock 的区别12345678一、synchronized和lock的用法区别（1）synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。（2）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对 象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。二、synchronized和lock性能区别synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致 在Java1.6上synchronize的性能并不比Lock差。三、synchronized和lock机制区别（1）synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。（2）Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作（Compare and Swap）。 CAS 乐观锁12CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。 ABA 问题1234CAS会导致“ABA问题”。CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。 乐观锁的业务场景及实现方式123乐观锁（Optimistic Lock）：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。","categories":[],"tags":[]},{"title":"Hexo Github Page配置简介","slug":"20170509","date":"2017-05-08T14:00:00.000Z","updated":"2017-05-09T16:34:45.783Z","comments":true,"path":"2017/05/08/20170509/","link":"","permalink":"https://byxian.github.io/2017/05/08/20170509/","excerpt":"","text":"参考：https://sfantasy.gitbooks.io/node-in-action/content/zh/http://git.oschina.net/oschina/git-osc/wikis/%E5%B8%AE%E5%8A%A9#ssh-keyshttps://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85https://pages.github.com/ 最近换了一个新机器，所以软件环境需要重新配置例如博客的配置，所以做一个基本的记录，方便日后参考。 1. 安装Node.js安装 Node.js 的最佳方式是使用 nvm。cURL:1curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。1nvm install 4 或者您也可以下载 安装程序 来安装。 2. npm配置npm，一般认为是 Node Package Manager 的缩写，鉴于 npm在国内会受到 GFW 的影响，可以选择使用 Taonpm 作为 npm 的镜像，方便安装 npm 中的模块。 配置说明1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装模块从 registry.npm.taobao.org 安装所有模块. 当安装的时候发现安装的模块还没有同步过来, 淘宝 NPM 会自动在后台进行同步, 并且会让你从官方 NPM registry.npmjs.org 进行安装. 下次你再安装这个模块的时候, 就会直接从 淘宝 NPM 安装了.1cnpm install [name] 3. Hexo安装1234567$ cnpm install hexo-cli -g$ hexo init blog$ cd blog$ cnpm install$ hexo generate$ hexo clean$ hexo server 4. Git配置123456789# 用户名git config --global user.name &quot;你的名字&quot;# emailgit config --global user.email &quot;你的Email&quot;# 生成SSH Keysssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;# Creates a new ssh key using the provided email# 获取公钥，并复制到公有git库（github,gitoschina,alicode等）cat ~/.ssh/id_rsa.pub 5.Hexo配置安装主题：123hexo cleancd themesgit clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 针对每个主题做具体的配置不赘述。修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为indigo。然后本地预览：123hexo cleanhexo ghexo s 6. 关联Github Pages注册一个github的帐号，创建一个仓库，仓库的名称为username/username.github.io，具体创建过程详见：https://pages.github.com/。修改配置文件_config.xml:1234deploy: type: git repo: https://github.com/byxian/byxian.github.io branch: master 然后发布项目到github上面：1hexo deploy 有常用的域名可以顺带配置一下。在域名管理中对选定的域名进行解析，记录类型为CNAME,记录值为byxian.github.io。然后hexo的source中添加CNAME文件，里面填写域名，重新部署即可实现域名访问。","categories":[],"tags":[]},{"title":"MyBatis Generate使用介绍","slug":"MyBatis Generate使用介绍","date":"2017-04-23T14:00:00.000Z","updated":"2017-05-09T16:35:34.448Z","comments":true,"path":"2017/04/23/MyBatis Generate使用介绍/","link":"","permalink":"https://byxian.github.io/2017/04/23/MyBatis Generate使用介绍/","excerpt":"","text":"参考文档：http://mbg.cndocs.tk/ 新项目一般都会涉及到数据模型的代码封装工作，一般在进行物理模型出来以后就生成数据表时，需要封装ORM数据层，Hibernate我主要使用JBoss Tools，而Mybatis我使用的是MBG。 此处主要介绍如何将数据库反向工程为项目中的数据层，主要包括model,dao,xml。 MyBatis Generator (MBG) 可以通过以下方式运行： 从 命令提示符 使用 XML 配置文件 作为 Ant 任务 使用 XML 配置文件 作为 Maven Plugin 从另一个 Java 程序 使用 XML 配置文件 此处我用的是Maven Plugin作为运行方式。 第一步编写pom.xml(参考http://mbg.cndocs.tk/running/runningWithMaven.html） 第二步创建xml配置文件（xml配置参考http://mbg.cndocs.tk/configreference/xmlconfig.html） 主要配置参数我做如下简单介绍，详情参考文档：1234567classPathEntry为数据库驱动jar包路径jdbcConnection为数据库连接信息javaModelGenerator配置的是代码model层sqlMapGenerator配置的是代码xml层javaClientGenerator配置的是代码dao层table配置的是需要反向的表列表： tableName数据库表的名称(不包括schema或catalog)。这个元素是&lt;context&gt;元素的一个至少存在一个的必选子元素。 您可以指定不限制数量的table元素。如果需要，指定的值可以包含SQL通配符（通配符参见http://www.w3school.com.cn/sql/sql_wildcards.asp）。 我的工具项目结构: 第三步使用maven执行任务。 最后生成代码如下（当然一些配置需要完善，后续有空余时间会研究一下xml文件的参数配置）： demo下载参考","categories":[],"tags":[]},{"title":"技术人员为什么要写博客？","slug":"技术人员为什么要写博客？","date":"2017-04-20T14:00:00.000Z","updated":"2017-05-08T14:43:26.294Z","comments":true,"path":"2017/04/20/技术人员为什么要写博客？/","link":"","permalink":"https://byxian.github.io/2017/04/20/技术人员为什么要写博客？/","excerpt":"","text":"来源：Zery zhang 的博客 www.cnblogs.com/zery/p/3343893.html 本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 “激友”（对生活冲满激情的朋友）。 一、我心中的博客我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。 自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。 对学习的知识点进行验证，以确保理论值与实践值保持一致。 动手写，写完后再次检查校正并排版，然后发表。 针对网友的评论中提出的问题进行回复。 我写文章一般都会经历以上5上步，最终以上5步融合成一个结果那就是”一篇文章” 这一过程也是我心中对的”写博客”一词的诠释 二、为什么要写博客为自己写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点： 强化知识点： 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识，人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点，当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。 提升学习能力： 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样，找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的，以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再Google因为Google的结果与百度的会有所不同，Google结果中国外的文章相对会多一点，而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。 渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 ，群里的朋友还推荐了一种方法，比如我要学MVC 园子里很多人都写了 关于MVC的一系列文章，把那一系列的文章都看一遍，对于MVC就基本有了了解了，这便是学习能力的提升,对于某种技术用最短的时间做到了比较全面的了解 提升文字组织能力： 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。 提升逻辑思维能力： 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的，比如MVC，你不能只知道 M是什么V是什么 C是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。 为他人有意的：园子里有很多人都写过关于 MVC 框架 WCF 等等系列文章，目的就在于帮助新人快速上手，这个我深有体会，当初我开始学习MVC时就是看的T2噬菌体的MVC系列文章，整篇看完后再配合自己动手对于MVC就有了基本的了解了，在次感谢园子里无私献的大牛们。而以上行为就是有意的帮助。 无意的：很多时候在开发项目的过程中，遇到了技术问题，花了时间解决后，有人会写博客记录，并附上解决方法旨在当再次遇到问题时直接看下文章就知道如何处理了，而碰巧的是，这种问题不止他一个人遇到了。很多人在开发时也遇到了这个问题，在网上找答案时，就找到了这篇文章，并根据文章提供的解决方法，顺利的解决了问题，这种帮助就是无意的帮助。 三、一定要写博客吗古人云：一份耕耘，一份收获。 以下这些是帮助他人而得到的一些认可，并非主观上去追求的。 MVP：微软每年都颁发MVP给那些经常与其他专业人士分享知识和专业技能，受人尊敬、信任，而且平易近人的专家。而这个称号则是对你写的博客质量的肯定。 知名度：文章写得好的人，技术水平肯定也很好，知道的人多了，知名度就有了，比如园子里排名前10的大家都知道，都看过他们的文章。 尊敬：对于技术界的大神，都是受人敬仰的，在园子里或者工作中也是一样的，在心里对大神们都是默默的佩服！至少我是这样啦，哈哈~也是我学习的榜样！ 五、总结我所认的写博客是对自己所了解知识的强化，分享，自身能力的提升。当然 写 博客只是一种方法而以，只要能达到提升自我的效果什么方法都是可以的。 之前有看过一篇文章：《即便没有读者，你也要写博客》 ，其中也讲解了很多写博客的好处。 而我写博客是希望，能提升自己的综合能力，并把自己的知识与经验分享给大家，如果有幸我的分享帮助了一些人，那将使我更加欣慰。 最后附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！ 注：我代表不了大家，所以以上观点只代表我个人。","categories":[],"tags":[]},{"title":"为什么有些技术人员不写博客？","slug":"为什么有些技术人员不写博客？","date":"2017-04-20T13:20:00.000Z","updated":"2017-05-08T14:43:26.294Z","comments":true,"path":"2017/04/20/为什么有些技术人员不写博客？/","link":"","permalink":"https://byxian.github.io/2017/04/20/为什么有些技术人员不写博客？/","excerpt":"","text":"来源： 伯乐在线 - bigship 常有人跟我讨论我在blog上发布过的博文，有时候他们还希望我来撰写某些文章。在讨论的过程中，我几乎总是会问为什么你自己不开一个博客，或者为其他人的博客做些贡献呢？当我在引导他们为技术类的主题写一些博文时，极少有人对此感兴趣。 我的母亲总是告诉我（以及她的学生们）每个人都有自己的故事。她说，写作可能是一种你不曾想到过的非常有益处的行为，直到你写的东西获得了其他人的喜爱和zan同。就像软件开发者为他们的用户开发软件一样，作家为他们的读者而写作。从来都没有什么论断说技术人员无法成为激励他人学习并乐于同他人分享知识的优秀作者。 我写这篇博文的目的就是想鼓励广大的技术人员去享受写作、高效的写作，并能够从中得到乐趣。我将翻出一些我曾经最常见到的关于为什么技术人员不愿意写博客的理由。 “我不认为我是某方面的专家。对于任何一个我能想到的主题，我都不是权威。”我首先想到的是这个理由，因为它将是我最需要去驳斥的观点。如果从这篇博文里你没有得到任何收获的话，那就记住这句话：你并不需要成为某方面的专家才能去写相关的文章。 翻翻我的博客你就能找到很多这样的例子。我自认为自己是某个方面，或者某两个方面的专家，但我在过去5年中写了超过450篇博文，我肯定不会只写我最在行的那一两个主题。写下你懂得的东西，要成为权威你就不能害怕去多做些研究。这方面有一个很好的例子就是我的一篇标题为“Kerberos for haters”的博文。我几乎没有任何有关Kerberos方面的经验。事实上，甚至在我的RHCA（RedHat系统部署工程师）认证考试中我都无法正确配置好它！但是，我对此做了相当多的研究，并开始慢慢理解了这一大坨东西是如何联系起来的。还有许多人都对Kerberos感到困惑，于是我决定将我所掌握的有关Kerberos方面的知识串接起来写成一篇博文。这篇博文引来了许多正面和负面的回复，很明显我发布的博文对一些读者起到了帮助作用，启发了一些人同时也得罪了一些人。 接下来看看下一个常遇到的理由： 如果我写的东西里面有些地方是错误的怎么办？在整个互联网面前犯错，这使我看起来就像是个傻瓜。这种事我早就经历过，都已经有些厌倦了。做个不恰当的假设，每个作者都至少会犯一次错。读者们会指出你的错误（有些读者会很含蓄的指出，而有些读者不会这样），下面就是你的责任了，要么更正你的大作要么说服你的读者是他们错了。我自己也曾经发表过含有错误的博文，而且我对于时不时的要去检查这些错误显得有些懒惰。就像我中学时的新闻学老师一直教导我的：对于一个错误，最重要的部分是你要如何去更正它，并从中汲取教训。总之，你一定会犯些错误的。只要你尽心尽力的对此做研究，并尽量减少错误，及时对错误做出回应，我想读者是不会怪您的。 说到错误，这里还有一个常见的理由： 我技术还不错，但我的拼写和语法很糟糕，我根本不擅长写作。这个问题很容易解决，如果你是那种什么事情都靠自己解决的人，那就拿起这本由Strunk和White合著的《The Elements of Style | 风格的要素》吧。网上有这本书的PDF版，或者你也可以借一本来读。无论你属于哪种情况，这本书详尽的描述了应该如何适当的加标点符号、如何组织句子和段落，以及如何正确地引用你的论点来源（对于写研究性的文章来说相当受用）。也许你并不想拿起一本如此枯燥的参考书来读，如果是这样的话，看看你身边有没有擅长写作的人。在大公司里你常常能在市场部或者公司的通讯录里找到一些愿意读你的文章并帮你做批注的伙计（谢谢你Garrett！，感谢你曾经为我修订过文章）。在 Fiverr（著名的5美元服务区，这是一个在线的信息平台，特色之处在于其收集那些价值5美元的事情，用户可以发布、接受或者分享这些信息）上我甚至找到了一些愿意以5美元的价格为我修订文章的人。 我不知道该写给谁看。如果我写的东西太简单了，那些真正的技术大牛们会不会觉得我就是个小白？如果我写的东西超级复杂，大多数人都接受不了又怎么办？这些我都经历过。大多数称职的Linux系统管理员都知道该如何添加和删除iptable规则，他们会觉得这是相当简单的任务。但是你知道吗，在我写过的超过450篇的博文里，这篇《deleting a single iptable rule》的访问量每个月都是排名前5！我每个月的点击量里有11%都来自这篇博文。人们要么通过这篇博文学到了一些知识，要么是他们忘记了该如何删除一条iptable规则，想通过这篇博文做快速的参考。不管如何，这篇博文对于许多人来说都是很有价值的，尽管在我看来这个主题相当的简单。反过来说，我曾经发疯写过一个完整的关于云主机冗余配置的how-to类文档，结合了LVS、glusterfs、MySQL on DRBD、memcached、haproxy以及Idirectord等各种技术。我觉得对于某些读者来说这个文档会很有价值，但肯定会搞晕绝大部分读者。事实证明我又错了，这篇博文长期占据我博客的前10名受欢迎的文章之一，通过这篇博文我收到的回复、email和IRC比其他的文章都要多。这再次证明，本是一篇我认为最没有用处的文章反倒成为了一个“话匣子”。 最后，让我们总结一下，如果你对于写作感到力不从心或者觉得气馁的话，记住下面这些忠告： 写你感兴趣的东西，不必在意你是否是专家 不要害怕失败 多多回复你的读者 就算你觉得没人会看你写的东西，也要坚持写下去 始终确保你的文章就代表着你的声音——这也是为什么写作是如此特别和吸引人的地方","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2016-07-27T14:11:30.000Z","updated":"2017-05-08T14:43:26.294Z","comments":true,"path":"2016/07/27/hello-world/","link":"","permalink":"https://byxian.github.io/2016/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}