{"meta":{"title":"Xian's Blog","subtitle":"见贤思齐焉，见不贤而内自省也。","description":"见贤思齐焉，见不贤而内自省也。","author":"Xian","url":"http://www.imxian.cn"},"pages":[],"posts":[{"title":"Java面试通关要点汇总集基础篇","slug":"Java面试通关要点汇总集基础篇","date":"2018-05-23T14:00:00.000Z","updated":"2018-05-23T16:05:57.669Z","comments":true,"path":"2018/05/23/Java面试通关要点汇总集基础篇/","link":"","permalink":"http://www.imxian.cn/2018/05/23/Java面试通关要点汇总集基础篇/","excerpt":"","text":"参考文档：http://www.spring4all.com/article/917 基础篇基本功面向对象的特征123456789面向对象的三个基本特征是：封装、继承、多态。封装封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。继承面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。多态多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。实现多态，有二种方式，覆盖，重载。 final, finally, finalize 的区别123final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.finally 是异常处理语句结构的一部分，表示总是执行.finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用. int 和 Integer 有什么区别1234567int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，是引用类型，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，Java中int和Integer关系是比较微妙的。关系如下：1、int是基本的数据类型；2、Integer是int的封装类；3、int和Integer都可以表示某一个数值；4、int和Integer不能够互用，因为他们两种不同的数据类型； 重载和重写的区别12重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。 抽象类和接口有什么区别 参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实现 实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法 抽象方法可以有main方法并且我们可以运行它 接口没有main方法，因此我们不能运行它。 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 说说反射的用途及实现123456Java反射机制是一个非常强大的功能，在很多的项目比如Spring，Mybatis都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决java泛型擦除等令人苦恼的问题。获取一个对象对应的反射类，在Java中有三种方法可以获取一个对象的反射类，通过getClass()方法通过Class.forName()方法；使用类.class通过类加载器实现，getClassLoader() 说说自定义注解的场景及实现12345登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。反射的实现在 Java 应用层面上讲，是通过对 Class 对象的操作实现的，Class 对象为我们提供了一系列方法对类进行操作。在 Jvm 这个角度来说，Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目按严格的顺序紧凑的排列在 Class 文件中，里面包含了类、方法、字段等等相关数据。通过对 Claas 数据流的处理我们即可得到字段、方法等数据。作者：LeopPro链接：https://juejin.im/post/5a9fad016fb9a028b77a5ce9来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 HTTP 请求的 GET 与 POST 方式的区别12341.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。3.首先是&quot;GET方式提交的数据最多只能是1024字节&quot;，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。POST是没有大小限制的，HTTP协议规范也没有进行大小限制 session 与 cookie 区别1234567891、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议：将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中 session 分布式处理123456789101112131415161718192021222324252627281.Session复制在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。优点：代码上不需要做支持和修改。缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。适用场景：只适用于Web服务器比较少且Session数据量少的情况。可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。2.Session粘滞将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。优点：使用简单，没有额外开销。缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。适用场景：对稳定性要求不是很高的业务情景。3.Session集中管理在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。优点：可靠性高，减少Web服务器的资源开销。缺点：实现上有些复杂，配置较多。适用场景：Web服务器较多、要求高可用性的情况。可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。4.基于Cookie管理这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。优点：不需要依赖额外外部存储，不需要额外配置。缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。适用场景：数据不重要、不敏感且数据量小的情况。总结这四种方式，相对来说，Session集中管理更加可靠，使用也是最多的。作者：JavaQ链接：https://www.jianshu.com/p/3dd4e06bdfa4來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 JDBC 流程12345（1）向DriverManager类注册驱动数据库驱动程序（2）调用DriverManager.getConnection方法， 通过JDBC URL，用户名，密码取得数据库连接的Connection对象。（3）获取Connection后， 便可以通过createStatement创建Statement用以执行SQL语句。（4） 有时候会得到查询结果，比如select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。（5）关闭数据库语句，关闭数据库连接。 MVC 设计思想12345MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。1）最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。2）最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。3）中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。 equals 与 == 的区别1234567==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。==返回true如果两个引用指向相同的对象，equals()的返回结果依赖于具体业务实现字符串的对比使用equals()代替==操作符使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。==返回true如果两个引用指向相同的对象，equals()的返回结果依赖于具体业务实现字符串的对比使用equals()代替==操作符 集合List 和 Set 区别1231、List,Set都是继承自Collection接口2、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）3、List接口有三个实现类：LinkedList，ArrayList，Vector ，Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet Arraylist 与 LinkedList 区别1234561) 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。2) 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。3) 类似于插入数据，删除数据时，LinkedList也优于ArrayList。4) LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。5) 你的应用不会随机访问数据。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。6) 你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。 ArrayList 与 Vector 区别12345链接：https://www.nowcoder.com/questionTerminal/0953369f92054cbfbf1024a1e723e04f来源：牛客网1） 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数2。2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50% ，这样,ArrayList就有利于节约内存空间。如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。 HashMap 和 Hashtable 的区别123451)HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。2) HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。3) 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。4) 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。5) HashMap不能保证随着时间的推移Map中的元素次序是不变的。 HashSet 和 HashMap 区别 HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 HashMap 和 ConcurrentHashMap 的区别123451）放入HashMap的元素是key-value对。2）底层说白了就是以前数据结构课程讲过的散列结构。3）要将元素放入到hashmap中，那么key的类型必须要实现实现hashcode方法，默认这个方法是根据对象的地址来计算的，具体我也记不太清楚了，接着还必须覆盖对象的equal方法。4）ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有5）ConcurrentHashMap在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。。。 HashMap 的工作原理及代码实现1234HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。 ConcurrentHashMap 的工作原理及代码实现123ConcurrentHashMap采用了非常精妙的&quot;分段锁&quot;策略，ConcurrentHashMap的主干是个Segment数组。Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。 线程创建线程的方式及实现123456789101112131415161718192021221.继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。（2）创建Thread子类的实例，即创建了线程对象。（3）调用线程对象的start()方法来启动该线程。2.通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。3.通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值采用实现Runnable、Callable接口的方式创见多线程时，优势是：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。劣势是：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。使用继承Thread类的方式创建多线程时优势是：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。 sleep() 、join（）、yield（）有什么区别1234567891011sleep() sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。wait() wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。 wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。 除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。 此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。yield() yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。join() join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行 说说 CountDownLatch 原理12CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。 说说 CyclicBarrier 原理1CyclicBarrier简介CyclicBarrier是一个同步辅助类,允许一组线程互相等待,直到到达某个公共屏障点(commonbarrierpoint)。因为该barrier在释放等待线程后可以重用,所以称它为循环的barrier。 说说 Semaphore 原理1Semaphore直译为信号。实际上Semaphore可以看做是一个信号的集合。不同的线程能够从Semaphore中获取若干个信号量。当Semaphore对象持有的信号量不足时，尝试从Semaphore中获取信号的线程将会阻塞。直到其他线程将信号量释放以后，阻塞的线程会被唤醒，重新尝试获取信号量。 说说 Exchanger 原理1当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。 说说 CountDownLatch 与 CyclicBarrier 区别12(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行;而CyclicBarrier则是允许N个线程相互等待。(02) CountDownLatch的计数器无法被重置;CyclicBarrier的计数器可以被重置后使用,因此它被称为是循环的barrier。 ThreadLocal 原理分析1ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。 讲讲线程池的实现原理1234567当提交一个新任务到线程池时，线程池的处理流程如下。1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 线程池的几种方式123456在Executors类里面提供了一些静态工厂，生成一些常用的线程池。1、newFixedThreadPool：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。2、newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。3、newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。4、newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。5、newSingleThreadScheduledExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 线程的生命周期1新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态 锁机制说说线程安全问题1234567线程安全是多线程领域的问题，线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。在Java多线程编程当中，提供了多种实现Java线程安全的方式：最简单的方式，使用Synchronization关键字:Java Synchronization介绍使用java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger使用java.util.concurrent.locks 包中的锁使用线程安全的集合ConcurrentHashMap使用volatile关键字，保证变量可见性（直接从内存读，而不是从线程cache读） volatile 实现原理12在JVM底层volatile是采用“内存屏障”来实现的。缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。 synchronize 实现原理1同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。 synchronized 与 lock 的区别12345678一、synchronized和lock的用法区别（1）synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。（2）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对 象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。二、synchronized和lock性能区别synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致 在Java1.6上synchronize的性能并不比Lock差。三、synchronized和lock机制区别（1）synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。（2）Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作（Compare and Swap）。 CAS 乐观锁12CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。 ABA 问题1234CAS会导致“ABA问题”。CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。 乐观锁的业务场景及实现方式123乐观锁（Optimistic Lock）：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。","categories":[],"tags":[]},{"title":"Hexo Github Page配置简介","slug":"20170509","date":"2017-05-08T14:00:00.000Z","updated":"2017-05-09T16:34:45.783Z","comments":true,"path":"2017/05/08/20170509/","link":"","permalink":"http://www.imxian.cn/2017/05/08/20170509/","excerpt":"","text":"参考：https://sfantasy.gitbooks.io/node-in-action/content/zh/http://git.oschina.net/oschina/git-osc/wikis/%E5%B8%AE%E5%8A%A9#ssh-keyshttps://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85https://pages.github.com/ 最近换了一个新机器，所以软件环境需要重新配置例如博客的配置，所以做一个基本的记录，方便日后参考。 1. 安装Node.js安装 Node.js 的最佳方式是使用 nvm。cURL:1curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。1nvm install 4 或者您也可以下载 安装程序 来安装。 2. npm配置npm，一般认为是 Node Package Manager 的缩写，鉴于 npm在国内会受到 GFW 的影响，可以选择使用 Taonpm 作为 npm 的镜像，方便安装 npm 中的模块。 配置说明1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装模块从 registry.npm.taobao.org 安装所有模块. 当安装的时候发现安装的模块还没有同步过来, 淘宝 NPM 会自动在后台进行同步, 并且会让你从官方 NPM registry.npmjs.org 进行安装. 下次你再安装这个模块的时候, 就会直接从 淘宝 NPM 安装了.1cnpm install [name] 3. Hexo安装1234567$ cnpm install hexo-cli -g$ hexo init blog$ cd blog$ cnpm install$ hexo generate$ hexo clean$ hexo server 4. Git配置123456789# 用户名git config --global user.name &quot;你的名字&quot;# emailgit config --global user.email &quot;你的Email&quot;# 生成SSH Keysssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;# Creates a new ssh key using the provided email# 获取公钥，并复制到公有git库（github,gitoschina,alicode等）cat ~/.ssh/id_rsa.pub 5.Hexo配置安装主题：123hexo cleancd themesgit clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 针对每个主题做具体的配置不赘述。修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为indigo。然后本地预览：123hexo cleanhexo ghexo s 6. 关联Github Pages注册一个github的帐号，创建一个仓库，仓库的名称为username/username.github.io，具体创建过程详见：https://pages.github.com/。修改配置文件_config.xml:1234deploy: type: git repo: https://github.com/byxian/byxian.github.io branch: master 然后发布项目到github上面：1hexo deploy 有常用的域名可以顺带配置一下。在域名管理中对选定的域名进行解析，记录类型为CNAME,记录值为byxian.github.io。然后hexo的source中添加CNAME文件，里面填写域名，重新部署即可实现域名访问。","categories":[],"tags":[]},{"title":"MyBatis Generate使用介绍","slug":"MyBatis Generate使用介绍","date":"2017-04-23T14:00:00.000Z","updated":"2017-05-09T16:35:34.448Z","comments":true,"path":"2017/04/23/MyBatis Generate使用介绍/","link":"","permalink":"http://www.imxian.cn/2017/04/23/MyBatis Generate使用介绍/","excerpt":"","text":"参考文档：http://mbg.cndocs.tk/ 新项目一般都会涉及到数据模型的代码封装工作，一般在进行物理模型出来以后就生成数据表时，需要封装ORM数据层，Hibernate我主要使用JBoss Tools，而Mybatis我使用的是MBG。 此处主要介绍如何将数据库反向工程为项目中的数据层，主要包括model,dao,xml。 MyBatis Generator (MBG) 可以通过以下方式运行： 从 命令提示符 使用 XML 配置文件 作为 Ant 任务 使用 XML 配置文件 作为 Maven Plugin 从另一个 Java 程序 使用 XML 配置文件 此处我用的是Maven Plugin作为运行方式。 第一步编写pom.xml(参考http://mbg.cndocs.tk/running/runningWithMaven.html） 第二步创建xml配置文件（xml配置参考http://mbg.cndocs.tk/configreference/xmlconfig.html） 主要配置参数我做如下简单介绍，详情参考文档：1234567classPathEntry为数据库驱动jar包路径jdbcConnection为数据库连接信息javaModelGenerator配置的是代码model层sqlMapGenerator配置的是代码xml层javaClientGenerator配置的是代码dao层table配置的是需要反向的表列表： tableName数据库表的名称(不包括schema或catalog)。这个元素是&lt;context&gt;元素的一个至少存在一个的必选子元素。 您可以指定不限制数量的table元素。如果需要，指定的值可以包含SQL通配符（通配符参见http://www.w3school.com.cn/sql/sql_wildcards.asp）。 我的工具项目结构: 第三步使用maven执行任务。 最后生成代码如下（当然一些配置需要完善，后续有空余时间会研究一下xml文件的参数配置）： demo下载参考","categories":[],"tags":[]},{"title":"技术人员为什么要写博客？","slug":"技术人员为什么要写博客？","date":"2017-04-20T14:00:00.000Z","updated":"2017-05-08T14:43:26.294Z","comments":true,"path":"2017/04/20/技术人员为什么要写博客？/","link":"","permalink":"http://www.imxian.cn/2017/04/20/技术人员为什么要写博客？/","excerpt":"","text":"来源：Zery zhang 的博客 www.cnblogs.com/zery/p/3343893.html 本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 “激友”（对生活冲满激情的朋友）。 一、我心中的博客我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。 自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。 对学习的知识点进行验证，以确保理论值与实践值保持一致。 动手写，写完后再次检查校正并排版，然后发表。 针对网友的评论中提出的问题进行回复。 我写文章一般都会经历以上5上步，最终以上5步融合成一个结果那就是”一篇文章” 这一过程也是我心中对的”写博客”一词的诠释 二、为什么要写博客为自己写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点： 强化知识点： 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识，人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点，当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。 提升学习能力： 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样，找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的，以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再Google因为Google的结果与百度的会有所不同，Google结果中国外的文章相对会多一点，而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。 渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 ，群里的朋友还推荐了一种方法，比如我要学MVC 园子里很多人都写了 关于MVC的一系列文章，把那一系列的文章都看一遍，对于MVC就基本有了了解了，这便是学习能力的提升,对于某种技术用最短的时间做到了比较全面的了解 提升文字组织能力： 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。 提升逻辑思维能力： 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的，比如MVC，你不能只知道 M是什么V是什么 C是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。 为他人有意的：园子里有很多人都写过关于 MVC 框架 WCF 等等系列文章，目的就在于帮助新人快速上手，这个我深有体会，当初我开始学习MVC时就是看的T2噬菌体的MVC系列文章，整篇看完后再配合自己动手对于MVC就有了基本的了解了，在次感谢园子里无私献的大牛们。而以上行为就是有意的帮助。 无意的：很多时候在开发项目的过程中，遇到了技术问题，花了时间解决后，有人会写博客记录，并附上解决方法旨在当再次遇到问题时直接看下文章就知道如何处理了，而碰巧的是，这种问题不止他一个人遇到了。很多人在开发时也遇到了这个问题，在网上找答案时，就找到了这篇文章，并根据文章提供的解决方法，顺利的解决了问题，这种帮助就是无意的帮助。 三、一定要写博客吗古人云：一份耕耘，一份收获。 以下这些是帮助他人而得到的一些认可，并非主观上去追求的。 MVP：微软每年都颁发MVP给那些经常与其他专业人士分享知识和专业技能，受人尊敬、信任，而且平易近人的专家。而这个称号则是对你写的博客质量的肯定。 知名度：文章写得好的人，技术水平肯定也很好，知道的人多了，知名度就有了，比如园子里排名前10的大家都知道，都看过他们的文章。 尊敬：对于技术界的大神，都是受人敬仰的，在园子里或者工作中也是一样的，在心里对大神们都是默默的佩服！至少我是这样啦，哈哈~也是我学习的榜样！ 五、总结我所认的写博客是对自己所了解知识的强化，分享，自身能力的提升。当然 写 博客只是一种方法而以，只要能达到提升自我的效果什么方法都是可以的。 之前有看过一篇文章：《即便没有读者，你也要写博客》 ，其中也讲解了很多写博客的好处。 而我写博客是希望，能提升自己的综合能力，并把自己的知识与经验分享给大家，如果有幸我的分享帮助了一些人，那将使我更加欣慰。 最后附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！ 注：我代表不了大家，所以以上观点只代表我个人。","categories":[],"tags":[]},{"title":"为什么有些技术人员不写博客？","slug":"为什么有些技术人员不写博客？","date":"2017-04-20T13:20:00.000Z","updated":"2017-05-08T14:43:26.294Z","comments":true,"path":"2017/04/20/为什么有些技术人员不写博客？/","link":"","permalink":"http://www.imxian.cn/2017/04/20/为什么有些技术人员不写博客？/","excerpt":"","text":"来源： 伯乐在线 - bigship 常有人跟我讨论我在blog上发布过的博文，有时候他们还希望我来撰写某些文章。在讨论的过程中，我几乎总是会问为什么你自己不开一个博客，或者为其他人的博客做些贡献呢？当我在引导他们为技术类的主题写一些博文时，极少有人对此感兴趣。 我的母亲总是告诉我（以及她的学生们）每个人都有自己的故事。她说，写作可能是一种你不曾想到过的非常有益处的行为，直到你写的东西获得了其他人的喜爱和zan同。就像软件开发者为他们的用户开发软件一样，作家为他们的读者而写作。从来都没有什么论断说技术人员无法成为激励他人学习并乐于同他人分享知识的优秀作者。 我写这篇博文的目的就是想鼓励广大的技术人员去享受写作、高效的写作，并能够从中得到乐趣。我将翻出一些我曾经最常见到的关于为什么技术人员不愿意写博客的理由。 “我不认为我是某方面的专家。对于任何一个我能想到的主题，我都不是权威。”我首先想到的是这个理由，因为它将是我最需要去驳斥的观点。如果从这篇博文里你没有得到任何收获的话，那就记住这句话：你并不需要成为某方面的专家才能去写相关的文章。 翻翻我的博客你就能找到很多这样的例子。我自认为自己是某个方面，或者某两个方面的专家，但我在过去5年中写了超过450篇博文，我肯定不会只写我最在行的那一两个主题。写下你懂得的东西，要成为权威你就不能害怕去多做些研究。这方面有一个很好的例子就是我的一篇标题为“Kerberos for haters”的博文。我几乎没有任何有关Kerberos方面的经验。事实上，甚至在我的RHCA（RedHat系统部署工程师）认证考试中我都无法正确配置好它！但是，我对此做了相当多的研究，并开始慢慢理解了这一大坨东西是如何联系起来的。还有许多人都对Kerberos感到困惑，于是我决定将我所掌握的有关Kerberos方面的知识串接起来写成一篇博文。这篇博文引来了许多正面和负面的回复，很明显我发布的博文对一些读者起到了帮助作用，启发了一些人同时也得罪了一些人。 接下来看看下一个常遇到的理由： 如果我写的东西里面有些地方是错误的怎么办？在整个互联网面前犯错，这使我看起来就像是个傻瓜。这种事我早就经历过，都已经有些厌倦了。做个不恰当的假设，每个作者都至少会犯一次错。读者们会指出你的错误（有些读者会很含蓄的指出，而有些读者不会这样），下面就是你的责任了，要么更正你的大作要么说服你的读者是他们错了。我自己也曾经发表过含有错误的博文，而且我对于时不时的要去检查这些错误显得有些懒惰。就像我中学时的新闻学老师一直教导我的：对于一个错误，最重要的部分是你要如何去更正它，并从中汲取教训。总之，你一定会犯些错误的。只要你尽心尽力的对此做研究，并尽量减少错误，及时对错误做出回应，我想读者是不会怪您的。 说到错误，这里还有一个常见的理由： 我技术还不错，但我的拼写和语法很糟糕，我根本不擅长写作。这个问题很容易解决，如果你是那种什么事情都靠自己解决的人，那就拿起这本由Strunk和White合著的《The Elements of Style | 风格的要素》吧。网上有这本书的PDF版，或者你也可以借一本来读。无论你属于哪种情况，这本书详尽的描述了应该如何适当的加标点符号、如何组织句子和段落，以及如何正确地引用你的论点来源（对于写研究性的文章来说相当受用）。也许你并不想拿起一本如此枯燥的参考书来读，如果是这样的话，看看你身边有没有擅长写作的人。在大公司里你常常能在市场部或者公司的通讯录里找到一些愿意读你的文章并帮你做批注的伙计（谢谢你Garrett！，感谢你曾经为我修订过文章）。在 Fiverr（著名的5美元服务区，这是一个在线的信息平台，特色之处在于其收集那些价值5美元的事情，用户可以发布、接受或者分享这些信息）上我甚至找到了一些愿意以5美元的价格为我修订文章的人。 我不知道该写给谁看。如果我写的东西太简单了，那些真正的技术大牛们会不会觉得我就是个小白？如果我写的东西超级复杂，大多数人都接受不了又怎么办？这些我都经历过。大多数称职的Linux系统管理员都知道该如何添加和删除iptable规则，他们会觉得这是相当简单的任务。但是你知道吗，在我写过的超过450篇的博文里，这篇《deleting a single iptable rule》的访问量每个月都是排名前5！我每个月的点击量里有11%都来自这篇博文。人们要么通过这篇博文学到了一些知识，要么是他们忘记了该如何删除一条iptable规则，想通过这篇博文做快速的参考。不管如何，这篇博文对于许多人来说都是很有价值的，尽管在我看来这个主题相当的简单。反过来说，我曾经发疯写过一个完整的关于云主机冗余配置的how-to类文档，结合了LVS、glusterfs、MySQL on DRBD、memcached、haproxy以及Idirectord等各种技术。我觉得对于某些读者来说这个文档会很有价值，但肯定会搞晕绝大部分读者。事实证明我又错了，这篇博文长期占据我博客的前10名受欢迎的文章之一，通过这篇博文我收到的回复、email和IRC比其他的文章都要多。这再次证明，本是一篇我认为最没有用处的文章反倒成为了一个“话匣子”。 最后，让我们总结一下，如果你对于写作感到力不从心或者觉得气馁的话，记住下面这些忠告： 写你感兴趣的东西，不必在意你是否是专家 不要害怕失败 多多回复你的读者 就算你觉得没人会看你写的东西，也要坚持写下去 始终确保你的文章就代表着你的声音——这也是为什么写作是如此特别和吸引人的地方","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2016-07-27T14:11:30.000Z","updated":"2017-05-08T14:43:26.294Z","comments":true,"path":"2016/07/27/hello-world/","link":"","permalink":"http://www.imxian.cn/2016/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}