<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Java面试通关要点汇总集核心篇 | Xian&#39;s Blog | 见贤思齐焉，见不贤而内自省也。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="参考文档：http://www.spring4all.com/article/929  核心篇数据存储MySQL 索引使用的注意事项 索引不会包含有NULL的列 1只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。  使用短索引 1对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试通关要点汇总集核心篇">
<meta property="og:url" content="https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/index.html">
<meta property="og:site_name" content="Xian&#39;s Blog">
<meta property="og:description" content="参考文档：http://www.spring4all.com/article/929  核心篇数据存储MySQL 索引使用的注意事项 索引不会包含有NULL的列 1只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。  使用短索引 1对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在">
<meta property="og:updated_time" content="2018-05-23T16:54:22.174Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试通关要点汇总集核心篇">
<meta name="twitter:description" content="参考文档：http://www.spring4all.com/article/929  核心篇数据存储MySQL 索引使用的注意事项 索引不会包含有NULL的列 1只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。  使用短索引 1对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在">
    
        <link rel="alternative" href="/atom.xml" title="Xian&#39;s Blog" type="application/atom+xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.4.8">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Xian</h5>
          <a href="mailto:imxian@aliyun.com" title="imxian@aliyun.com" class="mail">imxian@aliyun.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/byxian" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://weibo.com/u/5269810767" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Java面试通关要点汇总集核心篇</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Java面试通关要点汇总集核心篇</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-05-23T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2018-05-24
</time>


            
        </h5>
    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#核心篇"><span class="post-toc-number">1.</span> <span class="post-toc-text">核心篇</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据存储"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">数据存储</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#MySQL-索引使用的注意事项"><span class="post-toc-number">1.1.0.1.</span> <span class="post-toc-text">MySQL 索引使用的注意事项</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#说说反模式设计"><span class="post-toc-number">1.1.0.2.</span> <span class="post-toc-text">说说反模式设计</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#说说分库与分表设计"><span class="post-toc-number">1.1.0.3.</span> <span class="post-toc-text">说说分库与分表设计</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#分库与分表带来的分布式困境与应对之策"><span class="post-toc-number">1.1.0.4.</span> <span class="post-toc-text">分库与分表带来的分布式困境与应对之策</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#说说-SQL-优化之道"><span class="post-toc-number">1.1.0.5.</span> <span class="post-toc-text">说说 SQL 优化之道</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#MySQL-遇到的死锁问题"><span class="post-toc-number">1.1.0.6.</span> <span class="post-toc-text">MySQL 遇到的死锁问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#存储引擎的-InnoDB-与-MyISAM"><span class="post-toc-number">1.1.0.7.</span> <span class="post-toc-text">存储引擎的 InnoDB 与 MyISAM</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#数据库索引的原理"><span class="post-toc-number">1.1.0.8.</span> <span class="post-toc-text">数据库索引的原理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#为什么要用-B-tree"><span class="post-toc-number">1.1.0.9.</span> <span class="post-toc-text">为什么要用 B-tree</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#聚集索引与非聚集索引的区别"><span class="post-toc-number">1.1.0.10.</span> <span class="post-toc-text">聚集索引与非聚集索引的区别</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#limit-20000-加载很慢怎么解决"><span class="post-toc-number">1.1.0.11.</span> <span class="post-toc-text">limit 20000 加载很慢怎么解决</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#选择合适的分布式主键方案"><span class="post-toc-number">1.1.0.12.</span> <span class="post-toc-text">选择合适的分布式主键方案</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#选择合适的数据存储方案"><span class="post-toc-number">1.1.0.13.</span> <span class="post-toc-text">选择合适的数据存储方案</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ObjectId-规则"><span class="post-toc-number">1.1.0.14.</span> <span class="post-toc-text">ObjectId 规则</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#聊聊-MongoDB-使用场景"><span class="post-toc-number">1.1.0.15.</span> <span class="post-toc-text">聊聊 MongoDB 使用场景</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#倒排索引"><span class="post-toc-number">1.1.0.16.</span> <span class="post-toc-text">倒排索引</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#聊聊-ElasticSearch-使用场景"><span class="post-toc-number">1.1.0.17.</span> <span class="post-toc-text">聊聊 ElasticSearch 使用场景</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#缓存使用"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">缓存使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Redis-有哪些类型"><span class="post-toc-number">1.2.0.1.</span> <span class="post-toc-text">Redis 有哪些类型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Redis-内部结构"><span class="post-toc-number">1.2.0.2.</span> <span class="post-toc-text">Redis 内部结构</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#聊聊-Redis-使用场景"><span class="post-toc-number">1.2.0.3.</span> <span class="post-toc-text">聊聊 Redis 使用场景</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Redis-持久化机制"><span class="post-toc-number">1.2.0.4.</span> <span class="post-toc-text">Redis 持久化机制</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Redis-如何实现持久化"><span class="post-toc-number">1.2.0.5.</span> <span class="post-toc-text">Redis 如何实现持久化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Redis-集群方案与实现"><span class="post-toc-number">1.2.0.6.</span> <span class="post-toc-text">Redis 集群方案与实现</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Redis-为什么是单线程的"><span class="post-toc-number">1.2.0.7.</span> <span class="post-toc-text">Redis 为什么是单线程的</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#缓存奔溃"><span class="post-toc-number">1.2.0.8.</span> <span class="post-toc-text">缓存奔溃</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#缓存降级"><span class="post-toc-number">1.2.0.9.</span> <span class="post-toc-text">缓存降级</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#使用缓存的合理性问题"><span class="post-toc-number">1.2.0.10.</span> <span class="post-toc-text">使用缓存的合理性问题</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#消息队列"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">消息队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#消息队列的使用场景"><span class="post-toc-number">1.3.0.1.</span> <span class="post-toc-text">消息队列的使用场景</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#消息的重发补偿解决思路"><span class="post-toc-number">1.3.0.2.</span> <span class="post-toc-text">消息的重发补偿解决思路</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#消息的幂等性解决思路"><span class="post-toc-number">1.3.0.3.</span> <span class="post-toc-text">消息的幂等性解决思路</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#消息的堆积解决思路"><span class="post-toc-number">1.3.0.4.</span> <span class="post-toc-text">消息的堆积解决思路</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#自己如何实现消息队列"><span class="post-toc-number">1.3.0.5.</span> <span class="post-toc-text">自己如何实现消息队列</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#如何保证消息的有序性"><span class="post-toc-number">1.3.0.6.</span> <span class="post-toc-text">如何保证消息的有序性</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-Java面试通关要点汇总集之核心篇"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Java面试通关要点汇总集核心篇</h1>
        <div class="post-meta">
            <time class="post-time" title="2018年05月24日 0:00" datetime="2018-05-23T16:00:00.000Z"  itemprop="datePublished">2018-05-24</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>参考文档：<a href="http://www.spring4all.com/article/929" target="_blank" rel="external">http://www.spring4all.com/article/929</a></p>
</blockquote>
<h2 id="核心篇"><a href="#核心篇" class="headerlink" title="核心篇"></a>核心篇</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h5 id="MySQL-索引使用的注意事项"><a href="#MySQL-索引使用的注意事项" class="headerlink" title="MySQL 索引使用的注意事项"></a>MySQL 索引使用的注意事项</h5><ol>
<li><p>索引不会包含有NULL的列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。</div></pre></td></tr></table></figure>
</li>
<li><p>使用短索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</div></pre></td></tr></table></figure>
</li>
<li><p>索引列排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</div></pre></td></tr></table></figure>
</li>
<li><p>like语句操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。</div></pre></td></tr></table></figure>
</li>
<li><p>不要在列上进行运算</p>
</li>
<li>不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的</li>
<li><p>索引要建立在经常进行select操作的字段上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</div></pre></td></tr></table></figure>
</li>
<li><p>索引要建立在值比较唯一的字段上。</p>
</li>
<li>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。</li>
<li>在where和join中出现的列需要建立索引。</li>
<li>where的查询条件里有不等号(where column != …),mysql将无法使用索引。</li>
<li>如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。</li>
<li>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。<h5 id="说说反模式设计"><a href="#说说反模式设计" class="headerlink" title="说说反模式设计"></a>说说反模式设计</h5>简单的来说，反模式是指在对经常面对的问题经常使用的低效，不良，或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。在这里我举一个最简单的例子：在面向对象设计/编程中，有一条很重要的原则， 单一责任原则(Single responsibility principle)。其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能。很多维护老程序的开发人员们可能都遇过这种类，一个类里有几千行的代码，有很多功能，但是责任不明确单一。单元测试程序也变复杂无比。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是开发人员故意的。很多情况下主要是由于随着系统的年限，需求的变化，项目的资源压力，项目组人员流动，系统结构的变化而导致某些原先小型的，符合单一原则类慢慢的变的臃肿起来。最后当这个类变成了维护的噩梦(特别是原先熟悉的开发人员离职后)，重构该类就变成了一个不容易的工程。<h5 id="说说分库与分表设计"><a href="#说说分库与分表设计" class="headerlink" title="说说分库与分表设计"></a>说说分库与分表设计</h5>垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。<br>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。<br>众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。<br>然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。<br>水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。<br>水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。<br>以上摘抄自： <a href="http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table" target="_blank" rel="external">http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table</a><h5 id="分库与分表带来的分布式困境与应对之策"><a href="#分库与分表带来的分布式困境与应对之策" class="headerlink" title="分库与分表带来的分布式困境与应对之策"></a>分库与分表带来的分布式困境与应对之策</h5>数据迁移与扩容问题<br>前面介绍到水平分表策略归纳总结为随机分表和连续分表两种情况。连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。连续分表的另外一个好处在于比较容易，不需要考虑迁移旧的数据，只需要添加分表就可以自动扩容。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。<br>针对于水平分表的设计至关重要，需要评估中短期内业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要多少分片。对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。<br>表关联问题<br>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。<br>分页与排序问题<br>一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。<br>分布式事务问题<br>随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题。目前，分布式事务并没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。<br>分布式全局唯一ID<br>在单库单表的情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单。在分库分表的环境中，数据分布在不同的分表上，不能再借助数据库自增长特性。需要使用全局唯一 ID，例如 UUID、GUID等。关于如何选择合适的全局唯一 ID，我会在后面的章节中进行介绍。<br>摘抄自：<a href="http://blog.csdn.net/jiangpingjiangping/article/details/78069480" target="_blank" rel="external">http://blog.csdn.net/jiangpingjiangping/article/details/78069480</a><h5 id="说说-SQL-优化之道"><a href="#说说-SQL-优化之道" class="headerlink" title="说说 SQL 优化之道"></a>说说 SQL 优化之道</h5>一、一些常见的SQL实践<br>（1）负向条件查询不能使用索引<br>select from order where status!=0 and stauts!=1<br>not in/not exists都不是好习惯<br>可以优化为in查询：<br>select from order where status in(2,3)<br>（2）前导模糊查询不能使用索引<br>select from order where desc like ‘%XX’<br>而非前导模糊查询则可以：<br>select from order where desc like ‘XX%’<br>（3）数据区分度不大的字段不宜使用索引<br>select from user where sex=1<br>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。<br>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。<br>（4）在属性上进行计算不能命中索引<br>select from order where YEAR(date) &lt; = ‘2017’<br>即使date上建立了索引，也会全表扫描，可优化为值计算：<br>select from order where date &lt; = CURDATE()<br>或者：<br>select from order where date &lt; = ‘2017-01-01’<br>二、并非周知的SQL实践<br>（5）如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心<br>select from user where uid=?<br>select from user where login_name=?<br>原因：B-Tree索引的时间复杂度是O(log(n))；Hash索引的时间复杂度是O(1)<br>（6）允许为null的列，查询有潜在大坑<br>单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集<br>select from user where name != ‘shenjian’<br>如果name允许为null，索引不存储null值，结果集中不会包含这些记录。<br>所以，请使用not null约束以及默认值。<br>（7）复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致<br>用户中心建立了(login_name, passwd)的复合索引<br>select from user where login_name=? and passwd=?<br>select from user where passwd=? and login_name=?<br>都能够命中索引<br>select from user where login_name=?<br>也能命中索引，满足复合索引最左前缀<br>select from user where passwd=?<br>不能命中索引，不满足复合索引最左前缀<br>（8）使用ENUM而不是字符串<br>ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。<br>三、小众但有用的SQL实践<br>（9）如果明确知道只有一条结果返回，limit 1能够提高效率<br>select from user where login_name=?<br>可以优化为：<br>select from user where login_name=? limit 1<br>原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动<br>（10）把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果<br>select from order where date &lt; = CURDATE()<br>这不是一个好的SQL实践，应该优化为：<br>$curDate = date(‘Y-m-d’);<br>$res = mysqlquery(<br>‘select from order where date &lt; = $curDate’);<br>原因：<br>释放了数据库的CPU<br>多次调用，传入的SQL相同，才可以利用查询缓存<br>（11）强制类型转换会全表扫描<br>select from user where phone=13800001234<br>你以为会命中phone索引么？大错特错了，这个语句究竟要怎么改？<br>末了，再加一条，不要使用select *（潜台词，文章的SQL都不合格 ==），只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。<br>整理自：<a href="https://cloud.tencent.com/developer/article/1054203" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1054203</a><h5 id="MySQL-遇到的死锁问题"><a href="#MySQL-遇到的死锁问题" class="headerlink" title="MySQL 遇到的死锁问题"></a>MySQL 遇到的死锁问题</h5>产生死锁的四个必要条件：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。<br>下列方法有助于最大限度地降低死锁：<br>（1）按同一顺序访问对象。<br>（2）避免事务中的用户交互。<br>（3）保持事务简短并在一个批处理中。<br>（4）使用低隔离级别。<br>（5）使用绑定连接。<br>整理自： <a href="http://onwise.xyz/2017/04/20/mysql-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" target="_blank" rel="external">http://onwise.xyz/2017/04/20/mysql-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</a><h5 id="存储引擎的-InnoDB-与-MyISAM"><a href="#存储引擎的-InnoDB-与-MyISAM" class="headerlink" title="存储引擎的 InnoDB 与 MyISAM"></a>存储引擎的 InnoDB 与 MyISAM</h5></li>
<li>InnoDB不支持FULLTEXT类型的索引。</li>
<li>InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。</li>
<li>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</li>
<li>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</li>
<li>LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</li>
<li>另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”<h5 id="数据库索引的原理"><a href="#数据库索引的原理" class="headerlink" title="数据库索引的原理"></a>数据库索引的原理</h5>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。<h5 id="为什么要用-B-tree"><a href="#为什么要用-B-tree" class="headerlink" title="为什么要用 B-tree"></a>为什么要用 B-tree</h5>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。<h5 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h5>1).聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个<br>2).聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续<br>　3).聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序<br>　非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.<br>4).索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。<h5 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h5>mysql的性能低是因为数据库要去扫描N+M条记录，然后又要放弃之前N条记录，开销很大<br>解决思略：<br>1、前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用es等进行搜索<br>2、使用延迟关联，即先通用limit得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据<br>select a.* from a,(select id from table_1 where is_deleted=’N’ limit 100000,20) b where a.id = b.id<br>3、从业务上实现，不分页如此多，例如只能分页前100页，后面的不允许再查了<br>4、不使用limit N,M,而是使用limit N，即将offset转化为where条件。<h5 id="选择合适的分布式主键方案"><a href="#选择合适的分布式主键方案" class="headerlink" title="选择合适的分布式主键方案"></a>选择合适的分布式主键方案</h5></li>
<li>数据库自增长序列或字段</li>
<li>UUID</li>
<li>使用UUID to Int64的方法</li>
<li>Redis生成ID</li>
<li>Twitter的snowflake算法</li>
<li>利用zookeeper生成唯一ID</li>
<li>MongoDB的ObjectId<h5 id="选择合适的数据存储方案"><a href="#选择合适的数据存储方案" class="headerlink" title="选择合适的数据存储方案"></a>选择合适的数据存储方案</h5>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。<br>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。<br>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。<br>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。<br>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。<br>摘抄自：<a href="http://blog.720ui.com/2017/db_better_db_use/" target="_blank" rel="external">http://blog.720ui.com/2017/db_better_db_use/</a><h5 id="ObjectId-规则"><a href="#ObjectId-规则" class="headerlink" title="ObjectId 规则"></a>ObjectId 规则</h5>[0,1,2,3] [4,5,6] [7,8] [9,10,11]<br>时间戳 |机器码 |PID |计数器<br>前四位是时间戳，可以提供秒级别的唯一性。<br>接下来三位是所在主机的唯一标识符，通常是机器主机名的散列值。<br>接下来两位是产生ObjectId的PID，确保同一台机器上并发产生的ObjectId是唯一的。<br>前九位保证了同一秒钟不同机器的不同进程产生的ObjectId时唯一的。<br>最后三位是自增计数器，确保相同进程同一秒钟产生的ObjectId是唯一的。<br><a href="https://github.com/qianjiahao/MongoDB/wiki/MongoDB%E4%B9%8B_id%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99" target="_blank" rel="external">https://github.com/qianjiahao/MongoDB/wiki/MongoDB%E4%B9%8B_id%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99</a><h5 id="聊聊-MongoDB-使用场景"><a href="#聊聊-MongoDB-使用场景" class="headerlink" title="聊聊 MongoDB 使用场景"></a>聊聊 MongoDB 使用场景</h5>高伸缩性的场景<br>MongoDB 非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>日志系统的场景<br>日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>分布式文件存储<br>MongoDB 还适合存储大尺寸的数据，之前介绍的 GridFS 存储方案，就是基于 MongoDB 的分布式文件存储系统。<br>摘抄自： <a href="http://blog.720ui.com/2017/mongodb_core_use/" target="_blank" rel="external">http://blog.720ui.com/2017/mongodb_core_use/</a><h5 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h5>倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。<br>有两种不同的反向索引形式：<br>一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。<br>一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。<h5 id="聊聊-ElasticSearch-使用场景"><a href="#聊聊-ElasticSearch-使用场景" class="headerlink" title="聊聊 ElasticSearch 使用场景"></a>聊聊 ElasticSearch 使用场景</h5>全文搜索，这个是用的最多的。加上分词插件、拼音插件什么的可以做成强大的全文搜索引擎。<br>数据库，挺奇葩的用法，因为ES存数相同数据，更费空间，不过确实不错，因为他的强大统计分析汇总能力，再加上分布式P2P扩展能力，现在硬件又那么便宜，所以就有人拿来当数据库了。<br>在线统计分析引擎，日志系统。logstash，不用解释了吧。可以实时动态分析数据，很是爽。<h3 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h3><h5 id="Redis-有哪些类型"><a href="#Redis-有哪些类型" class="headerlink" title="Redis 有哪些类型"></a>Redis 有哪些类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">在Redis中有五种数据类型</div><div class="line">String----------字符串</div><div class="line">Hash------------字典</div><div class="line">List-------------列表</div><div class="line">Set--------------集合</div><div class="line">Sorted Set------有序集合</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="Redis-内部结构"><a href="#Redis-内部结构" class="headerlink" title="Redis 内部结构"></a>Redis 内部结构</h5><p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。type ：代表一个 value 对象具体是何种数据类型。<br>encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如：”123” “456”这样的字符串。<br>vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。<br>作者：zhanglbjames<br>链接：<a href="https://www.jianshu.com/p/f09480c05e42" target="_blank" rel="external">https://www.jianshu.com/p/f09480c05e42</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h5 id="聊聊-Redis-使用场景"><a href="#聊聊-Redis-使用场景" class="headerlink" title="聊聊 Redis 使用场景"></a>聊聊 Redis 使用场景</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">缓存</div><div class="line">会话缓存</div><div class="line">时效性</div><div class="line">访问频率</div><div class="line">计数器</div><div class="line">社交列表</div><div class="line">记录用户判定信息</div><div class="line">交集、并集和差集</div><div class="line">热门列表与排行榜</div><div class="line">最新动态</div><div class="line">消息队列</div><div class="line">摘抄自：http://blog.720ui.com/2017/redis_core_use/</div></pre></td></tr></table></figure>
<h5 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis有两种持久化机制RDB与AOF。</div><div class="line">摘抄自： http://shanks.leanote.com/post/Untitled-55ca439338f41148cd000759-22</div></pre></td></tr></table></figure>
<h5 id="Redis-如何实现持久化"><a href="#Redis-如何实现持久化" class="headerlink" title="Redis 如何实现持久化"></a>Redis 如何实现持久化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</div><div class="line">AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</div><div class="line">Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</div><div class="line">两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</div></pre></td></tr></table></figure>
<h5 id="Redis-集群方案与实现"><a href="#Redis-集群方案与实现" class="headerlink" title="Redis 集群方案与实现"></a>Redis 集群方案与实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">客户端分片</div><div class="line">基于代理的分片</div><div class="line">路由查询</div><div class="line">客户端分片</div><div class="line">由客户端决定key写入或者读取的节点。</div><div class="line">包括jedis在内的一些客户端，实现了客户端分片机制。</div><div class="line">路由查询</div><div class="line">将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</div><div class="line">开源方案</div></pre></td></tr></table></figure>
<h5 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</div></pre></td></tr></table></figure>
<h5 id="缓存奔溃"><a href="#缓存奔溃" class="headerlink" title="缓存奔溃"></a>缓存奔溃</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</div><div class="line">加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。</div></pre></td></tr></table></figure>
<h5 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h5><p>页面降级：在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；<br>页面片段降级：比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；<br>页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；<br>服务功能降级：比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；<br>读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；<br>写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。<br>爬虫降级：在大促活动时，可以将爬虫流量导向静态页或者返回空数据，从而保护后端稀缺资源。<br>自动开关降级<br>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。<br>超时降级<br>当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。<br>摘抄自： <a href="http://jinnianshilongnian.iteye.com/blog/2306477" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/2306477</a></p>
<h5 id="使用缓存的合理性问题"><a href="#使用缓存的合理性问题" class="headerlink" title="使用缓存的合理性问题"></a>使用缓存的合理性问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">热点数据，缓存才有价值</div><div class="line">频繁修改的数据，看情况考虑使用缓存</div><div class="line">数据不一致性</div><div class="line">缓存更新机制</div><div class="line">缓存可用性</div><div class="line">缓存服务降级</div><div class="line">缓存预热</div><div class="line">缓存穿透</div><div class="line">摘抄自： http://blog.720ui.com/2016/redis_action_01_use_core/</div></pre></td></tr></table></figure>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h5 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">校验用户名等信息，如果没问题会在数据库中添加一个用户记录</div><div class="line">如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信</div><div class="line">分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他</div><div class="line">发送给用户一个包含操作指南的系统通知</div></pre></td></tr></table></figure>
<h5 id="消息的重发补偿解决思路"><a href="#消息的重发补偿解决思路" class="headerlink" title="消息的重发补偿解决思路"></a>消息的重发补偿解决思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">可靠消息服务定时查询状态为已发送并超时的消息</div><div class="line">可靠消息将消息重新投递到 MQ 组件中</div><div class="line">下游应用监听消息，在满足幂等性的条件下，重新执行业务。</div><div class="line">下游应用通知可靠消息服务该消息已经成功消费。</div><div class="line">通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。</div></pre></td></tr></table></figure>
<h5 id="消息的幂等性解决思路"><a href="#消息的幂等性解决思路" class="headerlink" title="消息的幂等性解决思路"></a>消息的幂等性解决思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">查询操作</div><div class="line">查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</div><div class="line">删除操作</div><div class="line">删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</div><div class="line">3.唯一索引，防止新增脏数据</div><div class="line">比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</div><div class="line">token机制，防止页面重复提交</div><div class="line">悲观锁</div><div class="line">获取数据的时候加锁获取</div><div class="line">select * from table_xxx where id=&apos;xxx&apos; for update;</div><div class="line">注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</div><div class="line">悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</div><div class="line">乐观锁</div><div class="line">乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</div><div class="line">分布式锁</div><div class="line">还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</div><div class="line">select + insert</div><div class="line">并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</div><div class="line">注意：核心高并发流程不要用这种方法</div><div class="line">状态机幂等</div><div class="line">在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</div><div class="line">对外提供接口的api如何保证幂等</div><div class="line">如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号</div><div class="line">source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</div><div class="line">摘抄自： http://825635381.iteye.com/blog/2276077</div></pre></td></tr></table></figure>
<h5 id="消息的堆积解决思路"><a href="#消息的堆积解决思路" class="headerlink" title="消息的堆积解决思路"></a>消息的堆积解决思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">如果还没开始投入使用kafka，那应该在设计分区数的时候，尽量设置的多点（当然也不要太大，太大影响延迟，具体可以参考我前面提到的文章），从而提升生产和消费的并行度，避免消费太慢导致消费堆积。</div><div class="line">增大批次</div><div class="line">瓶颈在消费吞吐量的时候，增加批次也可以改善性能</div><div class="line">增加线程数</div><div class="line">如果一些消费者组中的消费者线程还是有1个消费者线程消费多个分区的情况，建议增加消费者线程。尽量1个消费者线程对应1个分区，从而发挥现有分区数下的最大并行度。</div><div class="line">摘抄自： https://kaimingwan.com/post/framworks/kafka/kafkaxiao-xi-dui-ji-chu-li</div></pre></td></tr></table></figure>
<h5 id="自己如何实现消息队列"><a href="#自己如何实现消息队列" class="headerlink" title="自己如何实现消息队列"></a>自己如何实现消息队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">大体上的设计是由一条线程1执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.</div><div class="line">添加一条线程1主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,</div><div class="line">当任务队列长度达到最大值时,线程1将被阻塞,等待线程2,3...从任务队列取出任务执行。</div><div class="line">作者：DrJasonZhang</div><div class="line">链接：https://www.jianshu.com/p/2d2271ecc64d</div><div class="line">來源：简书</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>
<h5 id="如何保证消息的有序性"><a href="#如何保证消息的有序性" class="headerlink" title="如何保证消息的有序性"></a>如何保证消息的有序性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。订单号相同的消息会被先后发送到同一个队列中，</div><div class="line">在获取到路由信息以后，会根据算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。</div></pre></td></tr></table></figure>
        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-05-23T16:54:22.174Z" itemprop="dateUpdated">2018年5月24日 0:54</time>
</span><br>


        这里写留言或版权声明：<a href="/2018/05/24/Java面试通关要点汇总集之核心篇/" target="_blank" rel="external">https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/</a>
    </div>
    <footer>
        <a href="https://byxian.github.io">
            <img src="/img/avatar.jpg" alt="Xian">
            Xian
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/&title=《Java面试通关要点汇总集核心篇》 — Xian's Blog&pic=https://byxian.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/&title=《Java面试通关要点汇总集核心篇》 — Xian's Blog&source=见贤思齐焉，见不贤而内自省也。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java面试通关要点汇总集核心篇》 — Xian's Blog&url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/&via=https://byxian.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/05/24/Java面试通关要点汇总集之工程篇/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java面试通关要点汇总集工程篇</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/05/24/Java面试通关要点汇总集之框架篇/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Java面试通关要点汇总集框架篇</h4>
      </a>
    </div>
  
</nav>



    







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            <span>博客内容遵循 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>Xian's Blog &copy; 2017 - 2018</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/&title=《Java面试通关要点汇总集核心篇》 — Xian's Blog&pic=https://byxian.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/&title=《Java面试通关要点汇总集核心篇》 — Xian's Blog&source=见贤思齐焉，见不贤而内自省也。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java面试通关要点汇总集核心篇》 — Xian's Blog&url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/&via=https://byxian.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://byxian.github.io/2018/05/24/Java面试通关要点汇总集之核心篇/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsUlEQVR42u3aQU4kMRAEQP7/afa60m4PmVX2AFL0CcGM2+GDy6Tr4yN+Ph+efz/z9PnXYyZveRrnwIOHh4d3aOpPL05GSCaUTPdptGTOeHh4eLd5+dCvwW0JacfM54yHh4f3M3mz8+3s2I2Hh4f3e3ltSZgdtV9/Cw8PD+8n8NoJbfD5YboNfPHw8PDew5sdhb/35yv3e3h4eHjrW/XZ0bb9ZF5g6tni4eHhXeC1V/jJK2c7dn6MzkfGw8PDu8GbBbKbAGLfTFAEJXh4eHgXeLMLp82F1iacbaNhPDw8vNu8NgVtj8752xNw0QqGh4eHd5mXBASnrtPyxcqXILq7w8PDw1vw9jFB+5t9eFG0XuHh4eFd481aBNrtfh8Z55EHHh4e3jt5mxS0Pawny5eXn8eeCDw8PLwLvHxbzzf0WfDaFokvSggeHh7eNd7s9bNAth2zJv09Ph4eHt41Xt3GVDZO5YfmPLSNFhcPDw/vLbz98XqWA8yKzReLiIeHh3eB93qDnrVntcFEfrW2aUrAw8PDO8vLD7XJC5LFapcmKVr1NRgeHh7egreZbnvRlRSM/ABdFDY8PDy8Q7zkC6fCgnzTn8H+MzIeHh7eBV79oTgsyMGzb70uVB/DNcDDw8NLeW0LVB6wthHtZiarGBcPDw9vxMsDhfrafhFt5MFHUfHw8PDwLvPa4OD1Nr1ppRpey+Hh4eFd4yXbdxuzzhoIZk/dNICHh4c34n2WzyxmbWPf9kLu8a94eHh4F3ibbTcpG/mxuO0Ua2eCh4eHd5aXFIP9tNoj9bFwBA8PD+8ab7Ypn4owzrZ8PXZG4OHh4X0TL7nyT16fxwr5mAcKAx4eHt5beJvJnRoZDw8P7/28vFV09uJ85E0ZiHrK8PDw8Na89h/+zWXYJnqYLT0eHh7eUd4f0NANATbphIEAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };



</script>

<script src="/js/main.min.js?v=1.4.8"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.4.8" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</body>
</html>
