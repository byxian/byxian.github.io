<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xian&#39;s Blog</title>
  <subtitle>见贤思齐焉，见不贤而内自省也。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.imxian.cn/"/>
  <updated>2018-05-23T16:54:22.174Z</updated>
  <id>http://www.imxian.cn/</id>
  
  <author>
    <name>Xian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java面试通关要点汇总集核心篇</title>
    <link href="http://www.imxian.cn/2018/05/24/Java%E9%9D%A2%E8%AF%95%E9%80%9A%E5%85%B3%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB%E9%9B%86%E4%B9%8B%E6%A0%B8%E5%BF%83%E7%AF%87/"/>
    <id>http://www.imxian.cn/2018/05/24/Java面试通关要点汇总集之核心篇/</id>
    <published>2018-05-23T16:00:00.000Z</published>
    <updated>2018-05-23T16:54:22.174Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考文档：<a href="http://www.spring4all.com/article/929" target="_blank" rel="external">http://www.spring4all.com/article/929</a></p>
</blockquote>
<h2 id="核心篇"><a href="#核心篇" class="headerlink" title="核心篇"></a>核心篇</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h5 id="MySQL-索引使用的注意事项"><a href="#MySQL-索引使用的注意事项" class="headerlink" title="MySQL 索引使用的注意事项"></a>MySQL 索引使用的注意事项</h5><ol>
<li><p>索引不会包含有NULL的列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。</div></pre></td></tr></table></figure>
</li>
<li><p>使用短索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</div></pre></td></tr></table></figure>
</li>
<li><p>索引列排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</div></pre></td></tr></table></figure>
</li>
<li><p>like语句操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。</div></pre></td></tr></table></figure>
</li>
<li><p>不要在列上进行运算</p>
</li>
<li>不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的</li>
<li><p>索引要建立在经常进行select操作的字段上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</div></pre></td></tr></table></figure>
</li>
<li><p>索引要建立在值比较唯一的字段上。</p>
</li>
<li>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。</li>
<li>在where和join中出现的列需要建立索引。</li>
<li>where的查询条件里有不等号(where column != …),mysql将无法使用索引。</li>
<li>如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。</li>
<li>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。<h5 id="说说反模式设计"><a href="#说说反模式设计" class="headerlink" title="说说反模式设计"></a>说说反模式设计</h5>简单的来说，反模式是指在对经常面对的问题经常使用的低效，不良，或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。在这里我举一个最简单的例子：在面向对象设计/编程中，有一条很重要的原则， 单一责任原则(Single responsibility principle)。其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能。很多维护老程序的开发人员们可能都遇过这种类，一个类里有几千行的代码，有很多功能，但是责任不明确单一。单元测试程序也变复杂无比。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是开发人员故意的。很多情况下主要是由于随着系统的年限，需求的变化，项目的资源压力，项目组人员流动，系统结构的变化而导致某些原先小型的，符合单一原则类慢慢的变的臃肿起来。最后当这个类变成了维护的噩梦(特别是原先熟悉的开发人员离职后)，重构该类就变成了一个不容易的工程。<h5 id="说说分库与分表设计"><a href="#说说分库与分表设计" class="headerlink" title="说说分库与分表设计"></a>说说分库与分表设计</h5>垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。<br>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。<br>众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。<br>然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。<br>水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。<br>水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。<br>以上摘抄自： <a href="http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table" target="_blank" rel="external">http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table</a><h5 id="分库与分表带来的分布式困境与应对之策"><a href="#分库与分表带来的分布式困境与应对之策" class="headerlink" title="分库与分表带来的分布式困境与应对之策"></a>分库与分表带来的分布式困境与应对之策</h5>数据迁移与扩容问题<br>前面介绍到水平分表策略归纳总结为随机分表和连续分表两种情况。连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。连续分表的另外一个好处在于比较容易，不需要考虑迁移旧的数据，只需要添加分表就可以自动扩容。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。<br>针对于水平分表的设计至关重要，需要评估中短期内业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要多少分片。对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。<br>表关联问题<br>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。<br>分页与排序问题<br>一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。<br>分布式事务问题<br>随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题。目前，分布式事务并没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。<br>分布式全局唯一ID<br>在单库单表的情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单。在分库分表的环境中，数据分布在不同的分表上，不能再借助数据库自增长特性。需要使用全局唯一 ID，例如 UUID、GUID等。关于如何选择合适的全局唯一 ID，我会在后面的章节中进行介绍。<br>摘抄自：<a href="http://blog.csdn.net/jiangpingjiangping/article/details/78069480" target="_blank" rel="external">http://blog.csdn.net/jiangpingjiangping/article/details/78069480</a><h5 id="说说-SQL-优化之道"><a href="#说说-SQL-优化之道" class="headerlink" title="说说 SQL 优化之道"></a>说说 SQL 优化之道</h5>一、一些常见的SQL实践<br>（1）负向条件查询不能使用索引<br>select from order where status!=0 and stauts!=1<br>not in/not exists都不是好习惯<br>可以优化为in查询：<br>select from order where status in(2,3)<br>（2）前导模糊查询不能使用索引<br>select from order where desc like ‘%XX’<br>而非前导模糊查询则可以：<br>select from order where desc like ‘XX%’<br>（3）数据区分度不大的字段不宜使用索引<br>select from user where sex=1<br>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。<br>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。<br>（4）在属性上进行计算不能命中索引<br>select from order where YEAR(date) &lt; = ‘2017’<br>即使date上建立了索引，也会全表扫描，可优化为值计算：<br>select from order where date &lt; = CURDATE()<br>或者：<br>select from order where date &lt; = ‘2017-01-01’<br>二、并非周知的SQL实践<br>（5）如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心<br>select from user where uid=?<br>select from user where login_name=?<br>原因：B-Tree索引的时间复杂度是O(log(n))；Hash索引的时间复杂度是O(1)<br>（6）允许为null的列，查询有潜在大坑<br>单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集<br>select from user where name != ‘shenjian’<br>如果name允许为null，索引不存储null值，结果集中不会包含这些记录。<br>所以，请使用not null约束以及默认值。<br>（7）复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致<br>用户中心建立了(login_name, passwd)的复合索引<br>select from user where login_name=? and passwd=?<br>select from user where passwd=? and login_name=?<br>都能够命中索引<br>select from user where login_name=?<br>也能命中索引，满足复合索引最左前缀<br>select from user where passwd=?<br>不能命中索引，不满足复合索引最左前缀<br>（8）使用ENUM而不是字符串<br>ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。<br>三、小众但有用的SQL实践<br>（9）如果明确知道只有一条结果返回，limit 1能够提高效率<br>select from user where login_name=?<br>可以优化为：<br>select from user where login_name=? limit 1<br>原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动<br>（10）把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果<br>select from order where date &lt; = CURDATE()<br>这不是一个好的SQL实践，应该优化为：<br>$curDate = date(‘Y-m-d’);<br>$res = mysqlquery(<br>‘select from order where date &lt; = $curDate’);<br>原因：<br>释放了数据库的CPU<br>多次调用，传入的SQL相同，才可以利用查询缓存<br>（11）强制类型转换会全表扫描<br>select from user where phone=13800001234<br>你以为会命中phone索引么？大错特错了，这个语句究竟要怎么改？<br>末了，再加一条，不要使用select *（潜台词，文章的SQL都不合格 ==），只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。<br>整理自：<a href="https://cloud.tencent.com/developer/article/1054203" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1054203</a><h5 id="MySQL-遇到的死锁问题"><a href="#MySQL-遇到的死锁问题" class="headerlink" title="MySQL 遇到的死锁问题"></a>MySQL 遇到的死锁问题</h5>产生死锁的四个必要条件：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。<br>下列方法有助于最大限度地降低死锁：<br>（1）按同一顺序访问对象。<br>（2）避免事务中的用户交互。<br>（3）保持事务简短并在一个批处理中。<br>（4）使用低隔离级别。<br>（5）使用绑定连接。<br>整理自： <a href="http://onwise.xyz/2017/04/20/mysql-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" target="_blank" rel="external">http://onwise.xyz/2017/04/20/mysql-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</a><h5 id="存储引擎的-InnoDB-与-MyISAM"><a href="#存储引擎的-InnoDB-与-MyISAM" class="headerlink" title="存储引擎的 InnoDB 与 MyISAM"></a>存储引擎的 InnoDB 与 MyISAM</h5></li>
<li>InnoDB不支持FULLTEXT类型的索引。</li>
<li>InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。</li>
<li>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</li>
<li>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</li>
<li>LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</li>
<li>另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”<h5 id="数据库索引的原理"><a href="#数据库索引的原理" class="headerlink" title="数据库索引的原理"></a>数据库索引的原理</h5>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。<h5 id="为什么要用-B-tree"><a href="#为什么要用-B-tree" class="headerlink" title="为什么要用 B-tree"></a>为什么要用 B-tree</h5>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。<h5 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h5>1).聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个<br>2).聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续<br>　3).聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序<br>　非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.<br>4).索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。<h5 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h5>mysql的性能低是因为数据库要去扫描N+M条记录，然后又要放弃之前N条记录，开销很大<br>解决思略：<br>1、前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用es等进行搜索<br>2、使用延迟关联，即先通用limit得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据<br>select a.* from a,(select id from table_1 where is_deleted=’N’ limit 100000,20) b where a.id = b.id<br>3、从业务上实现，不分页如此多，例如只能分页前100页，后面的不允许再查了<br>4、不使用limit N,M,而是使用limit N，即将offset转化为where条件。<h5 id="选择合适的分布式主键方案"><a href="#选择合适的分布式主键方案" class="headerlink" title="选择合适的分布式主键方案"></a>选择合适的分布式主键方案</h5></li>
<li>数据库自增长序列或字段</li>
<li>UUID</li>
<li>使用UUID to Int64的方法</li>
<li>Redis生成ID</li>
<li>Twitter的snowflake算法</li>
<li>利用zookeeper生成唯一ID</li>
<li>MongoDB的ObjectId<h5 id="选择合适的数据存储方案"><a href="#选择合适的数据存储方案" class="headerlink" title="选择合适的数据存储方案"></a>选择合适的数据存储方案</h5>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。<br>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。<br>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。<br>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。<br>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。<br>摘抄自：<a href="http://blog.720ui.com/2017/db_better_db_use/" target="_blank" rel="external">http://blog.720ui.com/2017/db_better_db_use/</a><h5 id="ObjectId-规则"><a href="#ObjectId-规则" class="headerlink" title="ObjectId 规则"></a>ObjectId 规则</h5>[0,1,2,3] [4,5,6] [7,8] [9,10,11]<br>时间戳 |机器码 |PID |计数器<br>前四位是时间戳，可以提供秒级别的唯一性。<br>接下来三位是所在主机的唯一标识符，通常是机器主机名的散列值。<br>接下来两位是产生ObjectId的PID，确保同一台机器上并发产生的ObjectId是唯一的。<br>前九位保证了同一秒钟不同机器的不同进程产生的ObjectId时唯一的。<br>最后三位是自增计数器，确保相同进程同一秒钟产生的ObjectId是唯一的。<br><a href="https://github.com/qianjiahao/MongoDB/wiki/MongoDB%E4%B9%8B_id%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99" target="_blank" rel="external">https://github.com/qianjiahao/MongoDB/wiki/MongoDB%E4%B9%8B_id%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99</a><h5 id="聊聊-MongoDB-使用场景"><a href="#聊聊-MongoDB-使用场景" class="headerlink" title="聊聊 MongoDB 使用场景"></a>聊聊 MongoDB 使用场景</h5>高伸缩性的场景<br>MongoDB 非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>日志系统的场景<br>日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>分布式文件存储<br>MongoDB 还适合存储大尺寸的数据，之前介绍的 GridFS 存储方案，就是基于 MongoDB 的分布式文件存储系统。<br>摘抄自： <a href="http://blog.720ui.com/2017/mongodb_core_use/" target="_blank" rel="external">http://blog.720ui.com/2017/mongodb_core_use/</a><h5 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h5>倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。<br>有两种不同的反向索引形式：<br>一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。<br>一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。<h5 id="聊聊-ElasticSearch-使用场景"><a href="#聊聊-ElasticSearch-使用场景" class="headerlink" title="聊聊 ElasticSearch 使用场景"></a>聊聊 ElasticSearch 使用场景</h5>全文搜索，这个是用的最多的。加上分词插件、拼音插件什么的可以做成强大的全文搜索引擎。<br>数据库，挺奇葩的用法，因为ES存数相同数据，更费空间，不过确实不错，因为他的强大统计分析汇总能力，再加上分布式P2P扩展能力，现在硬件又那么便宜，所以就有人拿来当数据库了。<br>在线统计分析引擎，日志系统。logstash，不用解释了吧。可以实时动态分析数据，很是爽。<h3 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h3><h5 id="Redis-有哪些类型"><a href="#Redis-有哪些类型" class="headerlink" title="Redis 有哪些类型"></a>Redis 有哪些类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">在Redis中有五种数据类型</div><div class="line">String----------字符串</div><div class="line">Hash------------字典</div><div class="line">List-------------列表</div><div class="line">Set--------------集合</div><div class="line">Sorted Set------有序集合</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="Redis-内部结构"><a href="#Redis-内部结构" class="headerlink" title="Redis 内部结构"></a>Redis 内部结构</h5><p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。type ：代表一个 value 对象具体是何种数据类型。<br>encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如：”123” “456”这样的字符串。<br>vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。<br>作者：zhanglbjames<br>链接：<a href="https://www.jianshu.com/p/f09480c05e42" target="_blank" rel="external">https://www.jianshu.com/p/f09480c05e42</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h5 id="聊聊-Redis-使用场景"><a href="#聊聊-Redis-使用场景" class="headerlink" title="聊聊 Redis 使用场景"></a>聊聊 Redis 使用场景</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">缓存</div><div class="line">会话缓存</div><div class="line">时效性</div><div class="line">访问频率</div><div class="line">计数器</div><div class="line">社交列表</div><div class="line">记录用户判定信息</div><div class="line">交集、并集和差集</div><div class="line">热门列表与排行榜</div><div class="line">最新动态</div><div class="line">消息队列</div><div class="line">摘抄自：http://blog.720ui.com/2017/redis_core_use/</div></pre></td></tr></table></figure>
<h5 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis有两种持久化机制RDB与AOF。</div><div class="line">摘抄自： http://shanks.leanote.com/post/Untitled-55ca439338f41148cd000759-22</div></pre></td></tr></table></figure>
<h5 id="Redis-如何实现持久化"><a href="#Redis-如何实现持久化" class="headerlink" title="Redis 如何实现持久化"></a>Redis 如何实现持久化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</div><div class="line">AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</div><div class="line">Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</div><div class="line">两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</div></pre></td></tr></table></figure>
<h5 id="Redis-集群方案与实现"><a href="#Redis-集群方案与实现" class="headerlink" title="Redis 集群方案与实现"></a>Redis 集群方案与实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">客户端分片</div><div class="line">基于代理的分片</div><div class="line">路由查询</div><div class="line">客户端分片</div><div class="line">由客户端决定key写入或者读取的节点。</div><div class="line">包括jedis在内的一些客户端，实现了客户端分片机制。</div><div class="line">路由查询</div><div class="line">将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</div><div class="line">开源方案</div></pre></td></tr></table></figure>
<h5 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</div></pre></td></tr></table></figure>
<h5 id="缓存奔溃"><a href="#缓存奔溃" class="headerlink" title="缓存奔溃"></a>缓存奔溃</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</div><div class="line">加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。</div></pre></td></tr></table></figure>
<h5 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h5><p>页面降级：在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；<br>页面片段降级：比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；<br>页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；<br>服务功能降级：比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；<br>读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；<br>写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。<br>爬虫降级：在大促活动时，可以将爬虫流量导向静态页或者返回空数据，从而保护后端稀缺资源。<br>自动开关降级<br>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。<br>超时降级<br>当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。<br>摘抄自： <a href="http://jinnianshilongnian.iteye.com/blog/2306477" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/2306477</a></p>
<h5 id="使用缓存的合理性问题"><a href="#使用缓存的合理性问题" class="headerlink" title="使用缓存的合理性问题"></a>使用缓存的合理性问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">热点数据，缓存才有价值</div><div class="line">频繁修改的数据，看情况考虑使用缓存</div><div class="line">数据不一致性</div><div class="line">缓存更新机制</div><div class="line">缓存可用性</div><div class="line">缓存服务降级</div><div class="line">缓存预热</div><div class="line">缓存穿透</div><div class="line">摘抄自： http://blog.720ui.com/2016/redis_action_01_use_core/</div></pre></td></tr></table></figure>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h5 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">校验用户名等信息，如果没问题会在数据库中添加一个用户记录</div><div class="line">如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信</div><div class="line">分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他</div><div class="line">发送给用户一个包含操作指南的系统通知</div></pre></td></tr></table></figure>
<h5 id="消息的重发补偿解决思路"><a href="#消息的重发补偿解决思路" class="headerlink" title="消息的重发补偿解决思路"></a>消息的重发补偿解决思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">可靠消息服务定时查询状态为已发送并超时的消息</div><div class="line">可靠消息将消息重新投递到 MQ 组件中</div><div class="line">下游应用监听消息，在满足幂等性的条件下，重新执行业务。</div><div class="line">下游应用通知可靠消息服务该消息已经成功消费。</div><div class="line">通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。</div></pre></td></tr></table></figure>
<h5 id="消息的幂等性解决思路"><a href="#消息的幂等性解决思路" class="headerlink" title="消息的幂等性解决思路"></a>消息的幂等性解决思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">查询操作</div><div class="line">查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</div><div class="line">删除操作</div><div class="line">删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</div><div class="line">3.唯一索引，防止新增脏数据</div><div class="line">比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</div><div class="line">token机制，防止页面重复提交</div><div class="line">悲观锁</div><div class="line">获取数据的时候加锁获取</div><div class="line">select * from table_xxx where id=&apos;xxx&apos; for update;</div><div class="line">注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</div><div class="line">悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</div><div class="line">乐观锁</div><div class="line">乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</div><div class="line">分布式锁</div><div class="line">还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</div><div class="line">select + insert</div><div class="line">并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</div><div class="line">注意：核心高并发流程不要用这种方法</div><div class="line">状态机幂等</div><div class="line">在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</div><div class="line">对外提供接口的api如何保证幂等</div><div class="line">如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号</div><div class="line">source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</div><div class="line">摘抄自： http://825635381.iteye.com/blog/2276077</div></pre></td></tr></table></figure>
<h5 id="消息的堆积解决思路"><a href="#消息的堆积解决思路" class="headerlink" title="消息的堆积解决思路"></a>消息的堆积解决思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">如果还没开始投入使用kafka，那应该在设计分区数的时候，尽量设置的多点（当然也不要太大，太大影响延迟，具体可以参考我前面提到的文章），从而提升生产和消费的并行度，避免消费太慢导致消费堆积。</div><div class="line">增大批次</div><div class="line">瓶颈在消费吞吐量的时候，增加批次也可以改善性能</div><div class="line">增加线程数</div><div class="line">如果一些消费者组中的消费者线程还是有1个消费者线程消费多个分区的情况，建议增加消费者线程。尽量1个消费者线程对应1个分区，从而发挥现有分区数下的最大并行度。</div><div class="line">摘抄自： https://kaimingwan.com/post/framworks/kafka/kafkaxiao-xi-dui-ji-chu-li</div></pre></td></tr></table></figure>
<h5 id="自己如何实现消息队列"><a href="#自己如何实现消息队列" class="headerlink" title="自己如何实现消息队列"></a>自己如何实现消息队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">大体上的设计是由一条线程1执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.</div><div class="line">添加一条线程1主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,</div><div class="line">当任务队列长度达到最大值时,线程1将被阻塞,等待线程2,3...从任务队列取出任务执行。</div><div class="line">作者：DrJasonZhang</div><div class="line">链接：https://www.jianshu.com/p/2d2271ecc64d</div><div class="line">來源：简书</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>
<h5 id="如何保证消息的有序性"><a href="#如何保证消息的有序性" class="headerlink" title="如何保证消息的有序性"></a>如何保证消息的有序性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。订单号相同的消息会被先后发送到同一个队列中，</div><div class="line">在获取到路由信息以后，会根据算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;http://www.spring4all.com/article/929&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.spring4all.com/article/929&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java面试通关要点汇总集基础篇</title>
    <link href="http://www.imxian.cn/2018/05/23/Java%E9%9D%A2%E8%AF%95%E9%80%9A%E5%85%B3%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB%E9%9B%86%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://www.imxian.cn/2018/05/23/Java面试通关要点汇总集基础篇/</id>
    <published>2018-05-23T14:00:00.000Z</published>
    <updated>2018-05-23T16:05:57.669Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考文档：<a href="http://www.spring4all.com/article/917" target="_blank" rel="external">http://www.spring4all.com/article/917</a></p>
</blockquote>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a>基本功</h3><h5 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">面向对象的三个基本特征是：封装、继承、多态。</div><div class="line">封装</div><div class="line">封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。</div><div class="line">封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</div><div class="line">继承</div><div class="line">面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</div><div class="line">多态</div><div class="line">多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</div><div class="line">实现多态，有二种方式，覆盖，重载。</div></pre></td></tr></table></figure>
<h5 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</div><div class="line">finally 是异常处理语句结构的一部分，表示总是执行.</div><div class="line">finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</div></pre></td></tr></table></figure>
<h5 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</div><div class="line">int的默认值为0，而Integer的默认值为null，是引用类型，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，</div><div class="line">Java中int和Integer关系是比较微妙的。关系如下：</div><div class="line">1、int是基本的数据类型；</div><div class="line">2、Integer是int的封装类；</div><div class="line">3、int和Integer都可以表示某一个数值；</div><div class="line">4、int和Integer不能够互用，因为他们两种不同的数据类型；</div></pre></td></tr></table></figure>
<h5 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</div><div class="line">重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</div></pre></td></tr></table></figure>
<h5 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h5><table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public、protected和default这些修饰符</td>
<td>接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<h5 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Java反射机制是一个非常强大的功能，在很多的项目比如Spring，Mybatis都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决java泛型擦除等令人苦恼的问题。</div><div class="line">获取一个对象对应的反射类，在Java中有三种方法可以获取一个对象的反射类，</div><div class="line">通过getClass()方法</div><div class="line">通过Class.forName()方法；</div><div class="line">使用类.class</div><div class="line">通过类加载器实现，getClassLoader()</div></pre></td></tr></table></figure>
<h5 id="说说自定义注解的场景及实现"><a href="#说说自定义注解的场景及实现" class="headerlink" title="说说自定义注解的场景及实现"></a>说说自定义注解的场景及实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。反射的实现在 Java 应用层面上讲，是通过对 Class 对象的操作实现的，Class 对象为我们提供了一系列方法对类进行操作。在 Jvm 这个角度来说，Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目按严格的顺序紧凑的排列在 Class 文件中，里面包含了类、方法、字段等等相关数据。通过对 Claas 数据流的处理我们即可得到字段、方法等数据。</div><div class="line">作者：LeopPro</div><div class="line">链接：https://juejin.im/post/5a9fad016fb9a028b77a5ce9</div><div class="line">来源：掘金</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>
<h5 id="HTTP-请求的-GET-与-POST-方式的区别"><a href="#HTTP-请求的-GET-与-POST-方式的区别" class="headerlink" title="HTTP 请求的 GET 与 POST 方式的区别"></a>HTTP 请求的 GET 与 POST 方式的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</div><div class="line">2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</div><div class="line">3.首先是&quot;GET方式提交的数据最多只能是1024字节&quot;，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。</div><div class="line">POST是没有大小限制的，HTTP协议规范也没有进行大小限制</div></pre></td></tr></table></figure>
<h5 id="session-与-cookie-区别"><a href="#session-与-cookie-区别" class="headerlink" title="session 与 cookie 区别"></a>session 与 cookie 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</div><div class="line">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</div><div class="line">考虑到安全应当使用session。</div><div class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</div><div class="line">考虑到减轻服务器性能方面，应当使用COOKIE。</div><div class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</div><div class="line">5、所以个人建议：</div><div class="line">将登陆信息等重要信息存放为SESSION</div><div class="line">其他信息如果需要保留，可以放在COOKIE中</div></pre></td></tr></table></figure>
<h5 id="session-分布式处理"><a href="#session-分布式处理" class="headerlink" title="session 分布式处理"></a>session 分布式处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">1.Session复制</div><div class="line">在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。</div><div class="line">优点：代码上不需要做支持和修改。</div><div class="line">缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。</div><div class="line">适用场景：只适用于Web服务器比较少且Session数据量少的情况。</div><div class="line">可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。</div><div class="line">2.Session粘滞</div><div class="line">将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。</div><div class="line">优点：使用简单，没有额外开销。</div><div class="line">缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。</div><div class="line">适用场景：对稳定性要求不是很高的业务情景。</div><div class="line">3.Session集中管理</div><div class="line">在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。</div><div class="line">优点：可靠性高，减少Web服务器的资源开销。</div><div class="line">缺点：实现上有些复杂，配置较多。</div><div class="line">适用场景：Web服务器较多、要求高可用性的情况。</div><div class="line">可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。</div><div class="line">4.基于Cookie管理</div><div class="line">这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。</div><div class="line">优点：不需要依赖额外外部存储，不需要额外配置。</div><div class="line">缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。</div><div class="line">适用场景：数据不重要、不敏感且数据量小的情况。</div><div class="line">总结</div><div class="line">这四种方式，相对来说，Session集中管理更加可靠，使用也是最多的。</div><div class="line">作者：JavaQ</div><div class="line">链接：https://www.jianshu.com/p/3dd4e06bdfa4</div><div class="line">來源：简书</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>
<h5 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）向DriverManager类注册驱动数据库驱动程序</div><div class="line">（2）调用DriverManager.getConnection方法， 通过JDBC URL，用户名，密码取得数据库连接的Connection对象。</div><div class="line">（3）获取Connection后， 便可以通过createStatement创建Statement用以执行SQL语句。</div><div class="line">（4） 有时候会得到查询结果，比如select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。</div><div class="line">（5）关闭数据库语句，关闭数据库连接。</div></pre></td></tr></table></figure>
<h5 id="MVC-设计思想"><a href="#MVC-设计思想" class="headerlink" title="MVC 设计思想"></a>MVC 设计思想</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。</div><div class="line">这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。</div><div class="line">1）最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。</div><div class="line">2）最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。</div><div class="line">3）中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。</div></pre></td></tr></table></figure>
<h5 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 == 的区别"></a>equals 与 == 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。</div><div class="line">使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。</div><div class="line">==返回true如果两个引用指向相同的对象，equals()的返回结果依赖于具体业务实现</div><div class="line">字符串的对比使用equals()代替==操作符</div><div class="line">使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。</div><div class="line">==返回true如果两个引用指向相同的对象，equals()的返回结果依赖于具体业务实现</div><div class="line">字符串的对比使用equals()代替==操作符</div></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h5 id="List-和-Set-区别"><a href="#List-和-Set-区别" class="headerlink" title="List 和 Set 区别"></a>List 和 Set 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、List,Set都是继承自Collection接口</div><div class="line">2、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）</div><div class="line">3、List接口有三个实现类：LinkedList，ArrayList，Vector ，Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet</div></pre></td></tr></table></figure>
<h5 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1) 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</div><div class="line">2) 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。</div><div class="line">3) 类似于插入数据，删除数据时，LinkedList也优于ArrayList。</div><div class="line">4) LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</div><div class="line">5) 你的应用不会随机访问数据。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。</div><div class="line">6) 你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。</div></pre></td></tr></table></figure>
<h5 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">链接：https://www.nowcoder.com/questionTerminal/0953369f92054cbfbf1024a1e723e04f</div><div class="line">来源：牛客网</div><div class="line">1） 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数2。</div><div class="line">2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50% ，这样,ArrayList就有利于节约内存空间。</div><div class="line">如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。</div></pre></td></tr></table></figure>
<h5 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1)HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</div><div class="line">2) HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</div><div class="line">3) 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</div><div class="line">4) 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</div><div class="line">5) HashMap不能保证随着时间的推移Map中的元素次序是不变的。</div></pre></td></tr></table></figure>
<h5 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h5><table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet </th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap实现了Map接口</td>
<td>HashSet实现了Set接口</td>
</tr>
<tr>
<td>HashMap储存键值对</td>
<td>HashSet仅仅存储对象</td>
</tr>
<tr>
<td>使用put()方法将元素放入map中</td>
<td>使用add()方法将元素放入set中</td>
</tr>
<tr>
<td>HashMap中使用键对象来计算hashcode值</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap比较快，因为是使用唯一的键来获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody>
</table>
<h5 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1）放入HashMap的元素是key-value对。</div><div class="line">2）底层说白了就是以前数据结构课程讲过的散列结构。</div><div class="line">3）要将元素放入到hashmap中，那么key的类型必须要实现实现hashcode方法，默认这个方法是根据对象的地址来计算的，具体我也记不太清楚了，接着还必须覆盖对象的equal方法。</div><div class="line">4）ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有</div><div class="line">5）ConcurrentHashMap在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。。。</div></pre></td></tr></table></figure>
<h5 id="HashMap-的工作原理及代码实现"><a href="#HashMap-的工作原理及代码实现" class="headerlink" title="HashMap 的工作原理及代码实现"></a>HashMap 的工作原理及代码实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。</div><div class="line">当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。</div><div class="line">当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。</div><div class="line">HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</div></pre></td></tr></table></figure>
<h5 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ConcurrentHashMap采用了非常精妙的&quot;分段锁&quot;策略，ConcurrentHashMap的主干是个Segment数组。</div><div class="line">Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。</div><div class="line">在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。</div></pre></td></tr></table></figure>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h5 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.继承Thread类创建线程类</div><div class="line">（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</div><div class="line">（2）创建Thread子类的实例，即创建了线程对象。</div><div class="line">（3）调用线程对象的start()方法来启动该线程。</div><div class="line">2.通过Runnable接口创建线程类</div><div class="line">（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</div><div class="line">（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</div><div class="line">（3）调用线程对象的start()方法来启动该线程。</div><div class="line">3.通过Callable和Future创建线程</div><div class="line">（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</div><div class="line">（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</div><div class="line">（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</div><div class="line">（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</div><div class="line">采用实现Runnable、Callable接口的方式创见多线程时，优势是：</div><div class="line">线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</div><div class="line">在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</div><div class="line">劣势是：</div><div class="line">编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</div><div class="line">使用继承Thread类的方式创建多线程时优势是：</div><div class="line">编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。</div><div class="line">劣势是：</div><div class="line">线程类已经继承了Thread类，所以不能再继承其他父类。</div></pre></td></tr></table></figure>
<h5 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sleep()</div><div class="line">　　sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。</div><div class="line">wait()</div><div class="line">　　wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。</div><div class="line">　　wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</div><div class="line">　　除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。</div><div class="line">　　此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。</div><div class="line">yield()</div><div class="line">　　yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。</div><div class="line">join()</div><div class="line">　　join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行</div></pre></td></tr></table></figure>
<h5 id="说说-CountDownLatch-原理"><a href="#说说-CountDownLatch-原理" class="headerlink" title="说说 CountDownLatch 原理"></a>说说 CountDownLatch 原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。</div><div class="line">CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。</div></pre></td></tr></table></figure>
<h5 id="说说-CyclicBarrier-原理"><a href="#说说-CyclicBarrier-原理" class="headerlink" title="说说 CyclicBarrier 原理"></a>说说 CyclicBarrier 原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CyclicBarrier简介CyclicBarrier是一个同步辅助类,允许一组线程互相等待,直到到达某个公共屏障点(commonbarrierpoint)。因为该barrier在释放等待线程后可以重用,所以称它为循环的barrier。</div></pre></td></tr></table></figure>
<h5 id="说说-Semaphore-原理"><a href="#说说-Semaphore-原理" class="headerlink" title="说说 Semaphore 原理"></a>说说 Semaphore 原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Semaphore直译为信号。实际上Semaphore可以看做是一个信号的集合。不同的线程能够从Semaphore中获取若干个信号量。当Semaphore对象持有的信号量不足时，尝试从Semaphore中获取信号的线程将会阻塞。直到其他线程将信号量释放以后，阻塞的线程会被唤醒，重新尝试获取信号量。</div></pre></td></tr></table></figure>
<h5 id="说说-Exchanger-原理"><a href="#说说-Exchanger-原理" class="headerlink" title="说说 Exchanger 原理"></a>说说 Exchanger 原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。</div></pre></td></tr></table></figure>
<h5 id="说说-CountDownLatch-与-CyclicBarrier-区别"><a href="#说说-CountDownLatch-与-CyclicBarrier-区别" class="headerlink" title="说说 CountDownLatch 与 CyclicBarrier 区别"></a>说说 CountDownLatch 与 CyclicBarrier 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行;而CyclicBarrier则是允许N个线程相互等待。</div><div class="line">(02) CountDownLatch的计数器无法被重置;CyclicBarrier的计数器可以被重置后使用,因此它被称为是循环的barrier。</div></pre></td></tr></table></figure>
<h5 id="ThreadLocal-原理分析"><a href="#ThreadLocal-原理分析" class="headerlink" title="ThreadLocal 原理分析"></a>ThreadLocal 原理分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。</div></pre></td></tr></table></figure>
<h5 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">当提交一个新任务到线程池时，线程池的处理流程如下。</div><div class="line">1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作</div><div class="line">线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</div><div class="line">2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这</div><div class="line">个工作队列里。如果工作队列满了，则进入下个流程。</div><div class="line">3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程</div><div class="line">来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</div></pre></td></tr></table></figure>
<h5 id="线程池的几种方式"><a href="#线程池的几种方式" class="headerlink" title="线程池的几种方式"></a>线程池的几种方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</div><div class="line">1、newFixedThreadPool：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</div><div class="line">2、newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</div><div class="line">3、newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</div><div class="line">4、newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</div><div class="line">5、newSingleThreadScheduledExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</div></pre></td></tr></table></figure>
<h5 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</div></pre></td></tr></table></figure>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><h5 id="说说线程安全问题"><a href="#说说线程安全问题" class="headerlink" title="说说线程安全问题"></a>说说线程安全问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">线程安全是多线程领域的问题，线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。</div><div class="line">在Java多线程编程当中，提供了多种实现Java线程安全的方式：</div><div class="line">最简单的方式，使用Synchronization关键字:Java Synchronization介绍</div><div class="line">使用java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger</div><div class="line">使用java.util.concurrent.locks 包中的锁</div><div class="line">使用线程安全的集合ConcurrentHashMap</div><div class="line">使用volatile关键字，保证变量可见性（直接从内存读，而不是从线程cache读）</div></pre></td></tr></table></figure>
<h5 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在JVM底层volatile是采用“内存屏障”来实现的。</div><div class="line">缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。</div></pre></td></tr></table></figure>
<h5 id="synchronize-实现原理"><a href="#synchronize-实现原理" class="headerlink" title="synchronize 实现原理"></a>synchronize 实现原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</div></pre></td></tr></table></figure>
<h5 id="synchronized-与-lock-的区别"><a href="#synchronized-与-lock-的区别" class="headerlink" title="synchronized 与 lock 的区别"></a>synchronized 与 lock 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">一、synchronized和lock的用法区别</div><div class="line">（1）synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</div><div class="line">（2）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对 象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。</div><div class="line">二、synchronized和lock性能区别</div><div class="line">synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致 在Java1.6上synchronize的性能并不比Lock差。</div><div class="line">三、synchronized和lock机制区别</div><div class="line">（1）synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。</div><div class="line">（2）Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作（Compare and Swap）。</div></pre></td></tr></table></figure>
<h5 id="CAS-乐观锁"><a href="#CAS-乐观锁" class="headerlink" title="CAS 乐观锁"></a>CAS 乐观锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</div><div class="line">CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</div></pre></td></tr></table></figure>
<h5 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CAS会导致“ABA问题”。</div><div class="line">CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</div><div class="line">比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</div><div class="line">部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</div></pre></td></tr></table></figure>
<h5 id="乐观锁的业务场景及实现方式"><a href="#乐观锁的业务场景及实现方式" class="headerlink" title="乐观锁的业务场景及实现方式"></a>乐观锁的业务场景及实现方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">乐观锁（Optimistic Lock）：</div><div class="line">每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</div><div class="line">比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;http://www.spring4all.com/article/917&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.spring4all.com/article/917&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo Github Page配置简介</title>
    <link href="http://www.imxian.cn/2017/05/08/20170509/"/>
    <id>http://www.imxian.cn/2017/05/08/20170509/</id>
    <published>2017-05-08T14:00:00.000Z</published>
    <updated>2017-05-09T16:34:45.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考：<br><a href="https://sfantasy.gitbooks.io/node-in-action/content/zh/" target="_blank" rel="external">https://sfantasy.gitbooks.io/node-in-action/content/zh/</a><br><a href="http://git.oschina.net/oschina/git-osc/wikis/%E5%B8%AE%E5%8A%A9#ssh-keys" target="_blank" rel="external">http://git.oschina.net/oschina/git-osc/wikis/%E5%B8%AE%E5%8A%A9#ssh-keys</a><br><a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="external">https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85</a><br><a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a>   </p>
</blockquote>
<p>最近换了一个新机器，所以软件环境需要重新配置例如博客的配置，所以做一个基本的记录，方便日后参考。   </p>
<h5 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h5><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>。<br>cURL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</div></pre></td></tr></table></figure></p>
<p>Wget:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</div></pre></td></tr></table></figure></p>
<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install 4</div></pre></td></tr></table></figure></p>
<p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="external">安装程序</a> 来安装。</p>
<h5 id="2-npm配置"><a href="#2-npm配置" class="headerlink" title="2. npm配置"></a>2. npm配置</h5><p>npm，一般认为是 Node Package Manager 的缩写，鉴于 npm在国内会受到 GFW 的影响，可以选择使用 <a href="https://npm.taobao.org/" target="_blank" rel="external">Taonpm</a> 作为 npm 的镜像，方便安装 npm 中的模块。   </p>
<h6 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure>
<h6 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h6><p>从 registry.npm.taobao.org 安装所有模块. 当安装的时候发现安装的模块还没有同步过来, 淘宝 NPM 会自动在后台进行同步, 并且会让你从官方 NPM registry.npmjs.org 进行安装. 下次你再安装这个模块的时候, 就会直接从 淘宝 NPM 安装了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install [name]</div></pre></td></tr></table></figure></p>
<h5 id="3-Hexo安装"><a href="#3-Hexo安装" class="headerlink" title="3. Hexo安装"></a>3. Hexo安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cnpm install hexo-cli -g</div><div class="line">$ hexo init blog</div><div class="line">$ cd blog</div><div class="line">$ cnpm install</div><div class="line">$ hexo generate</div><div class="line">$ hexo clean</div><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h5 id="4-Git配置"><a href="#4-Git配置" class="headerlink" title="4. Git配置"></a>4. Git配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 用户名</div><div class="line">git config --global user.name &quot;你的名字&quot;</div><div class="line"># email</div><div class="line">git config --global user.email &quot;你的Email&quot;</div><div class="line"># 生成SSH Keys</div><div class="line">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;# Creates a new ssh key using the provided email</div><div class="line"></div><div class="line"># 获取公钥，并复制到公有git库（github,gitoschina,alicode等）</div><div class="line">cat ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
<h5 id="5-Hexo配置"><a href="#5-Hexo配置" class="headerlink" title="5.Hexo配置"></a>5.Hexo配置</h5><p>安装主题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">cd themes</div><div class="line">git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</div></pre></td></tr></table></figure></p>
<p>针对每个主题做具体的配置不赘述。修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为indigo。然后本地预览：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<h5 id="6-关联Github-Pages"><a href="#6-关联Github-Pages" class="headerlink" title="6. 关联Github Pages"></a>6. 关联Github Pages</h5><p>注册一个github的帐号，创建一个仓库，仓库的名称为username/username.github.io，具体创建过程详见：<a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a>。<br>修改配置文件_config.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/byxian/byxian.github.io</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>然后发布项目到github上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure></p>
<p>有常用的域名可以顺带配置一下。在域名管理中对选定的域名进行解析，记录类型为CNAME,记录值为<strong>byxian.github.io</strong>。然后hexo的source中添加CNAME文件，里面填写域名，重新部署即可实现域名访问。</p>
<p><img src="http://global.bing.com/az/hprichbg/rb/TaihangMountains_EN-US6666930369_800x480.jpg" alt=""> </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://sfantasy.gitbooks.io/node-in-action/content/zh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://sfantasy.git
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatis Generate使用介绍</title>
    <link href="http://www.imxian.cn/2017/04/23/MyBatis%20Generate%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.imxian.cn/2017/04/23/MyBatis Generate使用介绍/</id>
    <published>2017-04-23T14:00:00.000Z</published>
    <updated>2017-05-09T16:35:34.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考文档：<a href="http://mbg.cndocs.tk/" target="_blank" rel="external">http://mbg.cndocs.tk/</a></p>
</blockquote>
<p>新项目一般都会涉及到数据模型的代码封装工作，一般在进行物理模型出来以后就生成数据表时，需要封装ORM数据层，Hibernate我主要使用JBoss Tools，而Mybatis我使用的是MBG。</p>
<p>此处主要介绍如何将数据库反向工程为项目中的数据层，主要包括model,dao,xml。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/20170423_0000.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>MyBatis Generator (MBG) 可以通过以下方式运行：</p>
<ul>
<li>从 <a href="http://mbg.cndocs.tk/running/runningFromCmdLine.html" target="_blank" rel="external">命令提示符</a> 使用 XML 配置文件</li>
<li>作为 <a href="http://mbg.cndocs.tk/running/runningWithAnt.html" target="_blank" rel="external">Ant 任务</a> 使用 XML 配置文件</li>
<li>作为 <a href="http://mbg.cndocs.tk/running/runningWithMaven.html" target="_blank" rel="external">Maven Plugin</a></li>
<li>从另一个 <a href="http://mbg.cndocs.tk/running/runningWithJava.html" target="_blank" rel="external">Java 程序</a> 使用 XML 配置文件</li>
</ul>
<p>此处我用的是Maven Plugin作为运行方式。</p>
<h6 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h6><p>编写pom.xml(参考<a href="http://mbg.cndocs.tk/running/runningWithMaven.html" target="_blank" rel="external">http://mbg.cndocs.tk/running/runningWithMaven.html</a>）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/20170423_0001.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h6 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h6><p>创建xml配置文件（xml配置参考<a href="http://mbg.cndocs.tk/configreference/xmlconfig.html" target="_blank" rel="external">http://mbg.cndocs.tk/configreference/xmlconfig.html</a>）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/20170423_0002.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>主要配置参数我做如下简单介绍，详情参考文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">classPathEntry为数据库驱动jar包路径</div><div class="line">jdbcConnection为数据库连接信息</div><div class="line">javaModelGenerator配置的是代码model层</div><div class="line">sqlMapGenerator配置的是代码xml层</div><div class="line">javaClientGenerator配置的是代码dao层</div><div class="line">table配置的是需要反向的表列表：</div><div class="line">  tableName数据库表的名称(不包括schema或catalog)。这个元素是&lt;context&gt;元素的一个至少存在一个的必选子元素。 您可以指定不限制数量的table元素。如果需要，指定的值可以包含SQL通配符（通配符参见http://www.w3school.com.cn/sql/sql_wildcards.asp）。</div></pre></td></tr></table></figure></p>
<p>我的工具项目结构:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/20170423_0003.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h6 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h6><p>使用maven执行任务。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/20170423_0004.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/20170423_0005.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h6 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h6><p>生成代码如下（当然一些配置需要完善，后续有空余时间会研究一下xml文件的参数配置）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/20170423_0006.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p><a href="http://imxian-bucket.oss-cn-shanghai.aliyuncs.com/20170423/WorkTileMBG.zip" target="_blank" rel="external">demo下载参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;http://mbg.cndocs.tk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mbg.cndocs.tk/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新项目一般都会涉及
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术人员为什么要写博客？</title>
    <link href="http://www.imxian.cn/2017/04/20/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
    <id>http://www.imxian.cn/2017/04/20/技术人员为什么要写博客？/</id>
    <published>2017-04-20T14:00:00.000Z</published>
    <updated>2017-05-08T14:43:26.294Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>来源：Zery zhang 的博客 www.cnblogs.com/zery/p/3343893.html</p>
</blockquote>
<p>本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 “激友”（对生活冲满激情的朋友）。   </p>
<h6 id="一、我心中的博客"><a href="#一、我心中的博客" class="headerlink" title="一、我心中的博客"></a>一、我心中的博客</h6><p>我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。   </p>
<ol>
<li>自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。</li>
<li>对学习的知识点进行验证，以确保理论值与实践值保持一致。</li>
<li>动手写，写完后再次检查校正并排版，然后发表。</li>
<li>针对网友的评论中提出的问题进行回复。</li>
</ol>
<p>我写文章一般都会经历以上5上步，最终以上5步融合成一个结果那就是”一篇文章” 这一过程也是我心中对的”写博客”一词的诠释</p>
<h6 id="二、为什么要写博客"><a href="#二、为什么要写博客" class="headerlink" title="二、为什么要写博客"></a>二、为什么要写博客</h6><h6 id="为自己"><a href="#为自己" class="headerlink" title="为自己"></a>为自己</h6><p>写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点：   </p>
<p><strong>强化知识点：</strong> 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识，人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点，当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。   </p>
<p><strong>提升学习能力：</strong> 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样，找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的，以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再Google因为Google的结果与百度的会有所不同，Google结果中国外的文章相对会多一点，而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。   </p>
<p>渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 ，群里的朋友还推荐了一种方法，比如我要学MVC 园子里很多人都写了 关于MVC的一系列文章，把那一系列的文章都看一遍，对于MVC就基本有了了解了，这便是学习能力的提升,对于某种技术用最短的时间做到了比较全面的了解</p>
<p><strong>提升文字组织能力：</strong> 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。   </p>
<p><strong>提升逻辑思维能力：</strong> 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的，比如MVC，你不能只知道 M是什么V是什么 C是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。   </p>
<h6 id="为他人"><a href="#为他人" class="headerlink" title="为他人"></a>为他人</h6><p><strong>有意的：</strong><br>园子里有很多人都写过关于 MVC 框架 WCF 等等系列文章，目的就在于帮助新人快速上手，这个我深有体会，当初我开始学习MVC时就是看的T2噬菌体的MVC系列文章，整篇看完后再配合自己动手对于MVC就有了基本的了解了，在次感谢园子里无私献的大牛们。而以上行为就是有意的帮助。</p>
<p><strong>无意的：</strong><br>很多时候在开发项目的过程中，遇到了技术问题，花了时间解决后，有人会写博客记录，并附上解决方法旨在当再次遇到问题时直接看下文章就知道如何处理了，而碰巧的是，这种问题不止他一个人遇到了。很多人在开发时也遇到了这个问题，在网上找答案时，就找到了这篇文章，并根据文章提供的解决方法，顺利的解决了问题，这种帮助就是无意的帮助。</p>
<h6 id="三、一定要写博客吗"><a href="#三、一定要写博客吗" class="headerlink" title="三、一定要写博客吗"></a>三、一定要写博客吗</h6><p>古人云：一份耕耘，一份收获。</p>
<p>以下这些是帮助他人而得到的一些认可，并非主观上去追求的。  </p>
<p><strong>MVP：</strong><br>微软每年都颁发MVP给那些经常与其他专业人士分享知识和专业技能，受人尊敬、信任，而且平易近人的专家。而这个称号则是对你写的博客质量的肯定。</p>
<p><strong>知名度：</strong><br>文章写得好的人，技术水平肯定也很好，知道的人多了，知名度就有了，比如园子里排名前10的大家都知道，都看过他们的文章。</p>
<p><strong>尊敬：</strong><br>对于技术界的大神，都是受人敬仰的，在园子里或者工作中也是一样的，在心里对大神们都是默默的佩服！至少我是这样啦，哈哈~也是我学习的榜样！</p>
<h6 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h6><p>我所认的写博客是对自己所了解知识的强化，分享，自身能力的提升。当然 写 博客只是一种方法而以，只要能达到提升自我的效果什么方法都是可以的。</p>
<p>之前有看过一篇文章：《即便没有读者，你也要写博客》 ，其中也讲解了很多写博客的好处。</p>
<p>而我写博客是希望，能提升自己的综合能力，并把自己的知识与经验分享给大家，如果有幸我的分享帮助了一些人，那将使我更加欣慰。</p>
<p>最后附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！</p>
<p>注：我代表不了大家，所以以上观点只代表我个人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;来源：Zery zhang 的博客 www.cnblogs.com/zery/p/3343893.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么有些技术人员不写博客？</title>
    <link href="http://www.imxian.cn/2017/04/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%8D%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
    <id>http://www.imxian.cn/2017/04/20/为什么有些技术人员不写博客？/</id>
    <published>2017-04-20T13:20:00.000Z</published>
    <updated>2017-05-08T14:43:26.294Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>来源： 伯乐在线 - bigship</p>
</blockquote>
<p>常有人跟我讨论我在blog上发布过的博文，有时候他们还希望我来撰写某些文章。在讨论的过程中，我几乎总是会问为什么你自己不开一个博客，或者为其他人的博客做些贡献呢？当我在引导他们为技术类的主题写一些博文时，极少有人对此感兴趣。   </p>
<p>我的母亲总是告诉我（以及她的学生们）每个人都有自己的故事。她说，写作可能是一种你不曾想到过的非常有益处的行为，直到你写的东西获得了其他人的喜爱和zan同。就像软件开发者为他们的用户开发软件一样，作家为他们的读者而写作。从来都没有什么论断说技术人员无法成为激励他人学习并乐于同他人分享知识的优秀作者。   </p>
<p>我写这篇博文的目的就是想鼓励广大的技术人员去享受写作、高效的写作，并能够从中得到乐趣。我将翻出一些我曾经最常见到的关于为什么技术人员不愿意写博客的理由。   </p>
<h6 id="“我不认为我是某方面的专家。对于任何一个我能想到的主题，我都不是权威。”"><a href="#“我不认为我是某方面的专家。对于任何一个我能想到的主题，我都不是权威。”" class="headerlink" title="“我不认为我是某方面的专家。对于任何一个我能想到的主题，我都不是权威。”"></a>“我不认为我是某方面的专家。对于任何一个我能想到的主题，我都不是权威。”</h6><p>我首先想到的是这个理由，因为它将是我最需要去驳斥的观点。如果从这篇博文里你没有得到任何收获的话，那就记住这句话：你并不需要成为某方面的专家才能去写相关的文章。   </p>
<p>翻翻我的博客你就能找到很多这样的例子。我自认为自己是某个方面，或者某两个方面的专家，但我在过去5年中写了超过450篇博文，我肯定不会只写我最在行的那一两个主题。写下你懂得的东西，要成为权威你就不能害怕去多做些研究。这方面有一个很好的例子就是我的一篇标题为“Kerberos for haters”的博文。我几乎没有任何有关Kerberos方面的经验。事实上，甚至在我的RHCA（RedHat系统部署工程师）认证考试中我都无法正确配置好它！但是，我对此做了相当多的研究，并开始慢慢理解了这一大坨东西是如何联系起来的。还有许多人都对Kerberos感到困惑，于是我决定将我所掌握的有关Kerberos方面的知识串接起来写成一篇博文。这篇博文引来了许多正面和负面的回复，很明显我发布的博文对一些读者起到了帮助作用，启发了一些人同时也得罪了一些人。   </p>
<p>接下来看看下一个常遇到的理由：   </p>
<h6 id="如果我写的东西里面有些地方是错误的怎么办？在整个互联网面前犯错，这使我看起来就像是个傻瓜。"><a href="#如果我写的东西里面有些地方是错误的怎么办？在整个互联网面前犯错，这使我看起来就像是个傻瓜。" class="headerlink" title="如果我写的东西里面有些地方是错误的怎么办？在整个互联网面前犯错，这使我看起来就像是个傻瓜。"></a>如果我写的东西里面有些地方是错误的怎么办？在整个互联网面前犯错，这使我看起来就像是个傻瓜。</h6><p>这种事我早就经历过，都已经有些厌倦了。做个不恰当的假设，每个作者都至少会犯一次错。读者们会指出你的错误（有些读者会很含蓄的指出，而有些读者不会这样），下面就是你的责任了，要么更正你的大作要么说服你的读者是他们错了。我自己也曾经发表过含有错误的博文，而且我对于时不时的要去检查这些错误显得有些懒惰。就像我中学时的新闻学老师一直教导我的：对于一个错误，最重要的部分是你要如何去更正它，并从中汲取教训。总之，你一定会犯些错误的。只要你尽心尽力的对此做研究，并尽量减少错误，及时对错误做出回应，我想读者是不会怪您的。   </p>
<p>说到错误，这里还有一个常见的理由：</p>
<h6 id="我技术还不错，但我的拼写和语法很糟糕，我根本不擅长写作。"><a href="#我技术还不错，但我的拼写和语法很糟糕，我根本不擅长写作。" class="headerlink" title="我技术还不错，但我的拼写和语法很糟糕，我根本不擅长写作。"></a>我技术还不错，但我的拼写和语法很糟糕，我根本不擅长写作。</h6><p>这个问题很容易解决，如果你是那种什么事情都靠自己解决的人，那就拿起这本由Strunk和White合著的《The Elements of Style  | 风格的要素》吧。网上有这本书的PDF版，或者你也可以借一本来读。无论你属于哪种情况，这本书详尽的描述了应该如何适当的加标点符号、如何组织句子和段落，以及如何正确地引用你的论点来源（对于写研究性的文章来说相当受用）。也许你并不想拿起一本如此枯燥的参考书来读，如果是这样的话，看看你身边有没有擅长写作的人。在大公司里你常常能在市场部或者公司的通讯录里找到一些愿意读你的文章并帮你做批注的伙计（谢谢你Garrett！，感谢你曾经为我修订过文章）。在 Fiverr（著名的5美元服务区，这是一个在线的信息平台，特色之处在于其收集那些价值5美元的事情，用户可以发布、接受或者分享这些信息）上我甚至找到了一些愿意以5美元的价格为我修订文章的人。   </p>
<h6 id="我不知道该写给谁看。如果我写的东西太简单了，那些真正的技术大牛们会不会觉得我就是个小白？如果我写的东西超级复杂，大多数人都接受不了又怎么办？"><a href="#我不知道该写给谁看。如果我写的东西太简单了，那些真正的技术大牛们会不会觉得我就是个小白？如果我写的东西超级复杂，大多数人都接受不了又怎么办？" class="headerlink" title="我不知道该写给谁看。如果我写的东西太简单了，那些真正的技术大牛们会不会觉得我就是个小白？如果我写的东西超级复杂，大多数人都接受不了又怎么办？"></a>我不知道该写给谁看。如果我写的东西太简单了，那些真正的技术大牛们会不会觉得我就是个小白？如果我写的东西超级复杂，大多数人都接受不了又怎么办？</h6><p>这些我都经历过。大多数称职的Linux系统管理员都知道该如何添加和删除iptable规则，他们会觉得这是相当简单的任务。但是你知道吗，在我写过的超过450篇的博文里，这篇《deleting a single iptable rule》的访问量每个月都是排名前5！我每个月的点击量里有11%都来自这篇博文。人们要么通过这篇博文学到了一些知识，要么是他们忘记了该如何删除一条iptable规则，想通过这篇博文做快速的参考。不管如何，这篇博文对于许多人来说都是很有价值的，尽管在我看来这个主题相当的简单。反过来说，我曾经发疯写过一个完整的关于云主机冗余配置的how-to类文档，结合了LVS、glusterfs、MySQL on DRBD、memcached、haproxy以及Idirectord等各种技术。我觉得对于某些读者来说这个文档会很有价值，但肯定会搞晕绝大部分读者。事实证明我又错了，这篇博文长期占据我博客的前10名受欢迎的文章之一，通过这篇博文我收到的回复、email和IRC比其他的文章都要多。这再次证明，本是一篇我认为最没有用处的文章反倒成为了一个“话匣子”。</p>
<p>最后，让我们总结一下，如果你对于写作感到力不从心或者觉得气馁的话，记住下面这些忠告：</p>
<ul>
<li>写你感兴趣的东西，不必在意你是否是专家</li>
<li>不要害怕失败</li>
<li>多多回复你的读者</li>
<li>就算你觉得没人会看你写的东西，也要坚持写下去</li>
<li>始终确保你的文章就代表着你的声音——这也是为什么写作是如此特别和吸引人的地方</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;来源： 伯乐在线 - bigship&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常有人跟我讨论我在blog上发布过的博文，有时候他们还希望我来撰写某些文章。在讨论的过程中，我几乎总是会问为什么你自己不开一个博客，或者为其他人的博客做些贡献呢？当我在
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.imxian.cn/2016/07/27/hello-world/"/>
    <id>http://www.imxian.cn/2016/07/27/hello-world/</id>
    <published>2016-07-27T14:11:30.000Z</published>
    <updated>2017-05-08T14:43:26.294Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
